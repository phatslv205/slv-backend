import eventlet
eventlet.monkey_patch() 
import os
import sys
import json
import re
import requests
import math
import base64
import openai
import fitz  # PyMuPDF
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from flask import Response
from openai_config import call_gpt_viet
from openai import OpenAI
from dotenv import load_dotenv
from flask import url_for
import random
from extensions import db
from models.user import User
from extensions import db, migrate
from flask_migrate import Migrate
from sqlalchemy import or_, func
from models.transaction import Transaction
from sqlalchemy import func
from models.friend import Friend
from models.message import Message
from models.friend_request import FriendRequest
from flask_socketio import SocketIO, join_room, emit
from flask_socketio import SocketIO, emit, join_room
from flask_socketio import emit 
load_dotenv()
api_key = os.getenv("OPENAI_API_KEY")
from utils_shared import normalize_package
from pytz import timezone
from datetime import datetime
from zoneinfo import ZoneInfo          # (Python ‚â•3.9) ‚Äì kh√¥ng c·∫ßn c√†i th√™m
VN_TZ = ZoneInfo("Asia/Ho_Chi_Minh")   # m√∫i gi·ªù VN
UTC_TZ = ZoneInfo("UTC")

from datetime import timedelta
from flask import request, jsonify
from werkzeug.utils import secure_filename
from flask import request, session, redirect, render_template
from gpt_vision_ocr import extract_with_gpt_vision
from openai_config import call_gpt_lite
def generate_image_from_prompt(prompt_text):
    try:
        print("üì§ ƒêang g·ª≠i prompt v·∫Ω h√¨nh t·ªõi DALL¬∑E:", prompt_text)
        client = create_openai_client()
        response = client.images.generate(
            model="dall-e-3",
            prompt=prompt_text,
            size="1024x1024",
            n=1
        )
        image_url = response.data[0].url
        if not image_url:
            print("‚ö†Ô∏è Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ·∫£nh t·ª´ OpenAI.")
            return None

        # T·∫£i ·∫£nh v·ªÅ
        img_data = requests.get(image_url).content

        # T·∫°o t√™n file ng·∫´u nhi√™n
        filename = f"img_{uuid.uuid4().hex[:8]}.png"
        save_path = os.path.join("static", "images", "uploads", filename)

        with open(save_path, "wb") as f:
            f.write(img_data)

        return f"/static/images/uploads/{filename}"

    except Exception as e:
        print("‚ùå L·ªói khi t·∫°o ·∫£nh t·ª´ DALL¬∑E:", e)
        return None

def rewrite_prompt_for_image(user_text):


    
    system_instruction = (
        "B·∫°n l√† chuy√™n gia t·∫°o prompt h√¨nh ·∫£nh cho AI v·∫Ω (nh∆∞ DALL¬∑E). "
        "Nhi·ªám v·ª• c·ªßa b·∫°n l√† vi·∫øt l·∫°i y√™u c·∫ßu t·ª´ ng∆∞·ªùi d√πng th√†nh m·ªôt m√¥ t·∫£ h√¨nh ·∫£nh C·ª§ TH·ªÇ, CHI TI·∫æT, TR·ª∞C QUAN v√† D·ªÑ HI·ªÇU cho AI t·∫°o ·∫£nh. "
        "ƒê·∫∑c bi·ªát, n·∫øu n·ªôi dung li√™n quan ƒë·∫øn to√°n h·ªçc, b·∫£ng vi·∫øt, ƒë·ªÅ ki·ªÉm tra ho·∫∑c n·ªôi dung c√≥ c·∫•u tr√∫c th√¨ ph·∫£i vi·∫øt r√µ r√†ng:\n"
        "- M√¥ t·∫£ c√≥ b·∫£ng tr·∫Øng ho·∫∑c b·∫£ng ƒëen\n"
        "- C√≥ bao nhi√™u c√¢u to√°n, n·ªôi dung m·ªói c√¢u c·ª• th·ªÉ\n"
        "- Tr√°nh vi·∫øt c√°c t·ª´ m∆° h·ªì nh∆∞ 'v·∫Ω ƒë·ªÅ to√°n ng·∫´u nhi√™n'\n"
        "- Kh√¥ng d√πng t·ª´ ng·∫Øn g·ªçn nh∆∞ 'chia ra', 'tr√¥ng gi·ªëng', 'ki·ªÉu nh∆∞'\n"
        "- Kh√¥ng vi·∫øt l·ªùi gi·∫£i th√≠ch, kh√¥ng vƒÉn v·∫ª, ch·ªâ in ra prompt d√πng ƒë·ªÉ t·∫°o ·∫£nh\n\n"
        "Ch·ªâ tr·∫£ v·ªÅ m√¥ t·∫£ ·∫£nh cu·ªëi c√πng, kh√¥ng th√™m l·ªùi d·∫´n."
    )

    try:
        client = create_openai_client()
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": system_instruction},
                {"role": "user", "content": user_text}
            ],
            temperature=0.4
        )
        return response.choices[0].message.content.strip()

    except Exception as e:
        print("‚ùå L·ªói rewrite_prompt:", e)
        return user_text  # fallback d√πng lu√¥n prompt g·ªëc
    
def cleanup_old_chats():
    folder = "chat_history"
    max_age = 24 * 60 * 60  # 24 gi·ªù
    now = time.time()

    for filename in os.listdir(folder):
        path = os.path.join(folder, filename)
        if os.path.isfile(path):
            if now - os.path.getmtime(path) > max_age:
                os.remove(path)
                print(f"[üßπ] ƒê√£ t·ª± xo√° file: {filename}")
OTP_FILE = "otp_codes.json"
def save_chat(user_id, history):
    folder = os.path.join("chat_history")
    os.makedirs(folder, exist_ok=True)
    file_path = os.path.join(folder, f"{user_id}.json")

    try:
        with open(file_path, "w", encoding="utf-8") as f:
            json.dump(history, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[üí•] L·ªói khi l∆∞u chat: {e}")

def load_otp_data():
    if not os.path.exists(OTP_FILE):
        return {}
    with open(OTP_FILE, "r", encoding="utf-8") as f:
        return json.load(f)

def save_otp_data(data):
    with open(OTP_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)


def now_vn():
    return datetime.utcnow() + timedelta(hours=7)



UPLOAD_FOLDER = 'static/images/uploads'
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
#  T·ª± ƒë·ªông xo√° ·∫£nh sau 7 ng√†y v√†v√† xo√° ·∫£nh c≈© sau 7 ng√†y (t·ª± ƒë·ªông m·ªói 24h) 
from threading import Thread
import time
from image_cleaner import clean_old_images

def auto_cleaner_loop():
    while True:
        clean_old_images()
        time.sleep(86400)  # ‚è±Ô∏è ch·∫°y m·ªói 1 ng√†y

Thread(target=auto_cleaner_loop, daemon=True).start()

from openai_config import create_openai_client


import smtplib
from email.mime.text import MIMEText

def send_otp_email(to_email, otp_code):
    subject = "M√£ x√°c th·ª±c OTP"
    body = f"M√£ x√°c th·ª±c c·ªßa b·∫°n l√†: {otp_code}\nTh·ªùi h·∫°n hi·ªáu l·ª±c: 5 ph√∫t."
    msg = MIMEText(body, "plain", "utf-8")
    msg["Subject"] = subject
    msg["From"] = "SolverViet <your_email@gmail.com>"  # thay b·∫±ng email th·∫≠t
    msg["To"] = to_email

    try:
        server = smtplib.SMTP_SSL("smtp.gmail.com", 465)
        server.login("your_email@gmail.com", "your_app_password")
        server.send_message(msg)
        server.quit()
        return True
    except Exception as e:
        print("L·ªói g·ª≠i email:", e)
        return False
def send_user_otp_email(to_email, otp_code):
    subject = "üîê M√£ OTP x√°c th·ª±c t·ª´ SolverViet"
    body = f"""Ch√†o b·∫°n üëã,

M√£ OTP c·ªßa b·∫°n l√†: {otp_code}

‚è≥ M√£ c√≥ hi·ªáu l·ª±c trong 5 ph√∫t. Vui l√≤ng kh√¥ng chia s·∫ª m√£ n√†y v·ªõi b·∫•t k·ª≥ ai!

Tr√¢n tr·ªçng,
SolverViet üáªüá≥"""

    msg = MIMEText(body, "plain", "utf-8")
    msg["Subject"] = subject
    msg["From"] = f"SolverViet <{os.getenv('EMAIL_ADDRESS')}>"
    msg["To"] = to_email

    try:
        server = smtplib.SMTP_SSL("smtp.gmail.com", 465)
        server.login(os.getenv("EMAIL_ADDRESS"), os.getenv("EMAIL_PASSWORD"))
        server.send_message(msg)
        server.quit()
        print("‚úÖ G·ª≠i OTP user th√†nh c√¥ng!")
        return True
    except Exception as e:
        print("‚ùå L·ªói g·ª≠i OTP user:", e)
        return False


import unicodedata
import random
import string

def generate_otp():
    from random import randint
    return str(random.randint(100000, 999999))


TELEGRAM_TOKEN = "7580016404:AAHoWnvRElJD3BXkZyxZQ4A4z34qXB-3s54"
TELEGRAM_CHAT_ID = "6894067779"
def send_telegram_message(message):
    print("üì§ ƒêang g·ª≠i telegram v·ªõi n·ªôi dung:")
    print(message)
    url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
    data = {
        "chat_id": TELEGRAM_CHAT_ID,
        "text": message,
        "parse_mode": "HTML"
    }
    try:
        response = requests.post(url, data=data)  # ‚úÖ S·ª≠a t·∫°i ƒë√¢y
        print("üì¨ Ph·∫£n h·ªìi Telegram:", response.text)
    except Exception as e:
        print("‚ö†Ô∏è L·ªói khi g·ª≠i Telegram:", e)
#H√ÄM G·ª¨I EMAIL
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart


from ip_blocker import record_ip, is_ip_blocked

from flask import get_flashed_messages
from flask import Flask, render_template, request, redirect, url_for, session, flash, get_flashed_messages
REQUESTS_FILE = "requests.json"


from datetime import datetime, timedelta

from flask import Flask, render_template, request, session, redirect, url_for



import time
import threading
from flask import flash 

import uuid

# === Th√™m th∆∞ m·ª•c hi·ªán t·∫°i v√†o sys.path ƒë·ªÉ import c√°c module n·ªôi b·ªô ===
sys.path.append(os.path.abspath(os.path.dirname(__file__)))

# ‚úÖ IMPORT c√°c h√†m x·ª≠ l√Ω qu·∫£n l√Ω ng∆∞·ªùi d√πng
from admin_utils import is_vip

def load_user_messages(user_id):
    inbox_path = f"user_data/{user_id}_inbox.txt"
    if os.path.exists(inbox_path):
        with open(inbox_path, "r", encoding="utf-8") as f:
            return [msg.strip() for msg in f.read().split("---\n\n") if msg.strip()]
    return []

def cap_nhat_trang_thai_vip(user: User):
    now = datetime.utcnow()

    user.vip_gpt_ai = bool(user.vip_until_gpt and now <= user.vip_until_gpt)
    user.vip_ai_lite = bool(user.vip_until_lite and now <= user.vip_until_lite)

    return {
        "vip_gpt_ai": user.vip_gpt_ai,
        "vip_ai_lite": user.vip_ai_lite,
    }


# ===== IMPORT TO√ÄN B·ªò =====
from flask import Flask
from config import Config


from extensions import db

# ====== FLASK APP ======
app = Flask(__name__)
socketio = SocketIO(app, cors_allowed_origins="*", async_mode="threading")
app.config.from_object(Config)
db.init_app(app)
migrate.init_app(app, db)
app.secret_key = 'b@o_m@t_2025_üî•' 
DATA_FILE = 'friends_data.json'
app.permanent_session_lifetime = timedelta(days=1)
from flask import render_template, request, redirect, abort, session
def is_admin():
    return session.get("is_admin") is True   
from functools import wraps

def admin_only(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not is_admin():
            return redirect("/admin_login")  # th√¢n thi·ªán h∆°n 404
        return f(*args, **kwargs)
    return decorated_function

@app.route("/admin_users")
@admin_only
def admin_users():
    users = User.query.all()
    user_count = len(users)

    users_data = []

    for user in users:
        u = {
            "username": user.username,
            "fullname": user.fullname,
            "bio": user.bio,
            "user_id": user.user_id,
            "online": getattr(user, "online", False),
        }

        gpt_type = user.vip_gpt

        # ‚úÖ T√≠nh s·ªë l∆∞·ª£t GPT / Lite c√≤n l·∫°i
        if getattr(user, "vip_ai_lite", False) and getattr(user, "vip_until_lite", None):
            u["gpt_remaining"] = "None"
            lite_used = getattr(user, "lite_usage", 0)
            lite_limit = getattr(user, "vip_lite_daily_limit", 50)
            remaining = lite_limit - lite_used
            u["lite_remaining"] = f"{remaining}/{lite_limit}"
        elif gpt_type == "5day":
            used = getattr(user, "gpt_usage_today", 0)
            remaining = 100 - used
            u["gpt_remaining"] = f"{remaining}/100"
            u["lite_remaining"] = "Kh√¥ng c√≥"
        elif gpt_type in ["15day", "30day"]:
            u["gpt_remaining"] = "‚àû"
            u["lite_remaining"] = "Kh√¥ng c√≥"
        else:
            u["gpt_remaining"] = "Kh√¥ng c√≥"
            u["lite_remaining"] = "Kh√¥ng c√≥"

        # ‚úÖ H·∫°n s·ª≠ d·ª•ng
        if user.vip_until_lite:
            u["vip_lite_display"] = user.vip_until_lite.strftime("%Y-%m-%d %H:%M:%S")
        else:
            u["vip_lite_display"] = "Kh√¥ng c√≥"

        if user.vip_until_gpt:
            u["vip_gpt_display"] = user.vip_until_gpt.strftime("%Y-%m-%d %H:%M:%S")
        else:
            u["vip_gpt_display"] = "Kh√¥ng c√≥"

        u["vip_gpt"] = user.vip_gpt or ""

        users_data.append(u)

    return render_template("admin_users.html", users=users_data, user_count=user_count)

def parse_dt(s):
    if not s or s.lower() in ["none", "kh√¥ng c√≥"]:
        return None
    s = s.strip()
    try:
        # N·∫øu ch·ªâ nh·∫≠p ng√†y ‚Üí t·ª± g√°n gi·ªù 23:59:59
        if len(s) == 10:
            s += " 23:59:59"
        return datetime.strptime(s, "%Y-%m-%d %H:%M:%S")
    except:
        return None
def parse_vip_duration(type_str):
    now = datetime.now()
    if type_str == "5day":
        return now + timedelta(days=4, hours=23, minutes=59, seconds=59)
    elif type_str == "15day":
        return now + timedelta(days=14, hours=23, minutes=59, seconds=59)
    elif type_str == "30day":
        return now + timedelta(days=29, hours=23, minutes=59, seconds=59)
    return None
@app.route("/admin_users/update", methods=["POST"])
@admin_only
def admin_users_update():
    old_name = request.form.get("username")
    new_name = request.form.get("new_username", old_name)

    vip_gpt = request.form.get("vip_gpt", "").strip()
    vip_toan = request.form.get("vip_toan", "").strip()
    vip_lite = request.form.get("vip_lite", "").strip()
    vip_gpt_type = request.form.get("vip_gpt_type", "").strip()
    gpt_unlimited = request.form.get("gpt_unlimited") == "on"

    user = User.query.filter_by(username=old_name).first()
    if user:
        if new_name != old_name:
            user.username = new_name

        # üéØ N·∫øu c√≥ ch·ªçn lo·∫°i g√≥i ‚Üí t·ª± sinh ng√†y h·∫øt h·∫°n
        if vip_gpt_type:
            gpt_time = parse_vip_duration(vip_gpt_type)
        else:
            gpt_time = parse_dt(vip_gpt)

        lite_time = parse_dt(vip_lite)
        toan_time = parse_dt(vip_toan)

        # ‚ùó N·∫øu c√≥ c·∫£ GPT v√† Lite ‚Üí ∆∞u ti√™n GPT
        if gpt_time:
            lite_time = None
        elif lite_time:
            gpt_time = None

        user.vip_until_gpt = gpt_time
        user.vip_gpt = vip_gpt_type or None
        user.vip_gpt_ai = bool(gpt_time)

        user.vip_until_lite = lite_time
        user.vip_ai_lite = bool(lite_time)


        db.session.commit()

    return redirect("/admin_users")


@app.route("/admin_users/toggle_block", methods=["POST"])
@admin_only
def admin_toggle_block():
    username = request.form.get("username")
    if not username:
        return "Thi·∫øu t√™n ng∆∞·ªùi d√πng", 400

    user = User.query.filter_by(username=username).first()
    if not user:
        return "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng", 404

    # ‚úÖ ƒê·∫£o ng∆∞·ª£c tr·∫°ng th√°i block
    user.is_blocked = not getattr(user, "is_blocked", False)
    db.session.commit()

    print(f"[DEBUG] ƒê√£ {'kho√°' if user.is_blocked else 'm·ªü kho√°'} user: {username}")
    return redirect("/admin_users")

def get_user_type():
    user_id = session.get("user_id")
    if not user_id:
        return "guest"

    user = User.query.filter_by(id=user_id).first()
    if not user:
        return "guest"

    try:
        if user.vip_until and datetime.strptime(user.vip_until, "%Y-%m-%d").date() >= datetime.now().date():
            return "vip"
    except:
        pass

    return "logged_in"
def check_lite_usage(user):

    MAX_FREE = 15
    MID_LIMIT = 5
    DAILY_LIMIT = 5
    now = now_vn()
    today = now.strftime("%Y-%m-%d")

    # ‚úÖ N·∫øu ch∆∞a ƒëƒÉng nh·∫≠p (guest)
    username = session.get("username")
    if not username:
        usage = session.get("lite_usage", 0)
        if usage >= MAX_FREE:
            return False
        session["lite_usage"] = usage + 1
        return True

    user = User.query.filter_by(username=username).first()
    if not user:
        return False

    usage = user.lite_usage or 0
    verified = user.is_verified or False

    # ‚úÖ G√≥i GPT kh√¥ng gi·ªõi h·∫°n
    try:
        if user.vip_until_gpt and now <= datetime.strptime(user.vip_until_gpt, "%Y-%m-%d %H:%M:%S"):
            return True
    except:
        pass

    if session.pop("just_verified", False):
        return True

    # ‚úÖ C√≥ g√≥i AI Lite ‚Üí 50 l∆∞·ª£t/ng√†y
    try:
        if user.vip_until_lite and now <= datetime.strptime(user.vip_until_lite, "%Y-%m-%d %H:%M:%S"):
            if user.lite_date != today:
                user.lite_usage = 0
                user.lite_date = today
                usage = 0
            if usage < 50:
                user.lite_usage = usage + 1
                db.session.commit()
                return True
            else:
                return False
    except:
        pass

    # ‚úÖ Ch∆∞a x√°c th·ª±c ‚Üí ch·ªâ 5 l∆∞·ª£t
    if not verified:
        if usage >= MID_LIMIT:
            return "require_verification"
        user.lite_usage = usage + 1
        db.session.commit()
        return True

    # ‚úÖ ƒê√£ x√°c th·ª±c ‚Üí t·ªïng 15 l∆∞·ª£t ƒë·∫ßu
    if verified and usage < MAX_FREE:
        user.lite_usage = usage + 1
        db.session.commit()
        return True

    # ‚úÖ ƒê√£ x√°c th·ª±c v√† v∆∞·ª£t qu√° 15 l∆∞·ª£t ‚Üí m·ªói ng√†y +5 l∆∞·ª£t
    if verified and usage >= MAX_FREE:
        if user.last_lite_free_date != today:
            user.last_lite_free_date = today
            user.lite_usage = MAX_FREE
            usage = MAX_FREE

        daily_used = usage - MAX_FREE
        if daily_used >= DAILY_LIMIT:
            return False

        user.lite_usage = usage + 1
        db.session.commit()
        return True

    return False
#GI·ªöI H·∫†N G√ìI V√Ä S·ª¨A TH·ª¶ C√îNG
def check_gpt_usage(user):
    now = now_vn()
    today = now.strftime("%Y-%m-%d")

    gpt_until = user.vip_until_gpt  # ‚úÖ d√πng tr·ª±c ti·∫øp datetime object
    gpt_type = user.vip_gpt

    print("üìå [GPT USAGE] gpt_type =", gpt_type)
    print("üìå [GPT USAGE] gpt_until =", gpt_until)

    if not gpt_until or not gpt_type:
        print("‚ùå Thi·∫øu g√≥i ho·∫∑c th·ªùi h·∫°n GPT")
        return False

    if now > gpt_until:
        print("‚ùå G√≥i GPT ƒë√£ h·∫øt h·∫°n")
        return False

    if user.gpt_unlimited:
        print("‚úÖ Unlimited GPT")
        return True

    if gpt_type in ["15day", "30day"]:
        print("‚úÖ G√≥i GPT d√†i ng√†y h·ª£p l·ªá")
        return True

    if gpt_type == "5day":
        usage_today = user.gpt_usage_today or 0
        usage_date = user.gpt_usage_date

        print("üìå usage_today =", usage_today)
        print("üìå usage_date =", usage_date)
        print("üìå today =", today)

        if usage_date != today:
            print("‚ÑπÔ∏è Reset l∆∞·ª£t GPT v√¨ ng√†y m·ªõi")
            usage_today = 0
            user.gpt_usage_today = 0
            user.gpt_usage_date = today

        if usage_today >= 100:
            print("‚ùå H·∫øt 100 l∆∞·ª£t GPT h√¥m nay")
            return False

        user.gpt_usage_today = usage_today + 1
        db.session.commit()
        print("‚úÖ C√≤n l∆∞·ª£t, tƒÉng usage_today:", user.gpt_usage_today)
        return True

    print("‚ùå Kh√¥ng kh·ªõp lo·∫°i g√≥i GPT")
    return False


def get_al_usage():
    return session.get("al_uses", 0)

def increment_al_usage():
    session["al_uses"] = get_al_usage() + 1



# ====== USER MANAGEMENT ======#

def get_username():
    return session.get("username")
def is_admin():
    return session.get("is_admin") is True


def update_solves(username):
    user = User.query.filter_by(username=username).first()
    if user:
        user.solves += 1
        db.session.commit()
def get_today():
    return datetime.now().strftime('%Y-%m-%d')

def get_solve_today(username):
    today = get_today()
    if username == "admin":
        return 0  # Admin kh√¥ng b·ªã gi·ªõi h·∫°n

    user = User.query.filter_by(username=username).first()
    if not user:
        return 0

    if not user.last_solve_date:
        user.last_solve_date = today
        user.solves = 0
        user.ads_used_today = 0
        db.session.commit()
    elif user.last_solve_date != today:
        if user.solves < 10:
            user.solves = max(0, user.solves - 5)
        else:
            user.solves = 0
        user.last_solve_date = today
        user.ads_used_today = 0
        db.session.commit()

    return user.solves
#==========B·∫¢O TR√å H·ªÜ TH·ªêNG==========#
def is_maintenance(feature):
    try:
        with open("maintenance_config.json", "r") as f:
            config = json.load(f)
            return config.get("all") or config.get(feature, False)
    except:
        return False
@app.route("/check_maintenance")
def check_maintenance():
    feature = request.args.get("feature", "all")
    return jsonify({"maintenance": is_maintenance(feature)})
@app.route("/maintenance")
def maintenance_page():
    return render_template("maintenance.html")


@app.route("/admin/bao-tri", methods=["GET"])
@admin_only
def bao_tri_router():
    return redirect("/admin/bao-tri-all")
    
@app.route("/admin/bao-tri-all", methods=["GET", "POST"])
@admin_only
def bao_tri_all():
    try:
        with open("maintenance_config.json", "r") as f:
            config = json.load(f)
    except FileNotFoundError:
        config = {
            "all": False,
            "gpt_chat": False,
            "chat_lite": False,
            "chat_ai_lite": False,
            "chat_ai_lite_daily": False,
            "home": False
        }

    if request.method == "POST":
        feature = request.form.get("feature")

        if feature and feature in config:
            # Toggle t·ª´ng ph·∫ßn c·ª• th·ªÉ
            config[feature] = not config[feature]
            flash(f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t b·∫£o tr√¨ cho ph·∫ßn: {feature}", "success")
        else:
            # Toggle to√†n h·ªá th·ªëng n·∫øu kh√¥ng c√≥ ph·∫ßn c·ª• th·ªÉ
            config["all"] = not config.get("all", False)
            flash("‚úÖ ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i b·∫£o tr√¨ to√†n b·ªô h·ªá th·ªëng.", "success")

        with open("maintenance_config.json", "w") as f:
            json.dump(config, f, indent=2)

        return redirect("/admin/bao-tri-all")

    is_on = config.get("all", False)
    return render_template("bao_tri_all.html", is_on=is_on, config=config)


# ====== LOGIN / REGISTER / LOGOUT ======
@app.route("/login", methods=["GET", "POST"])
def login():
    print("[DEBUG] üü¢ ƒê√£ v√†o h√†m LOGIN")

    message = request.args.get("message")

    if request.method == "POST":
        username = request.form["username"].strip()
        password = request.form["password"]

        user = User.query.filter_by(username=username).first()

        if user:
            if user.is_blocked:
                error = "üö´ T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã kh√≥a. N·∫øu ƒë√¢y l√† nh·∫ßm l·∫´n, vui l√≤ng g·ª≠i khi·∫øu n·∫°i t·∫°i <a href='/appeal' style='color:#4ea6ff;'>ƒë√¢y</a>."
                return render_template("login.html", error=error)

            if user.password == password:  # TODO: n·∫øu d√πng hash th√¨ s·ª≠a l·∫°i
                if user.wants_verification and not user.is_verified:
                    otp_code = generate_otp()
                    send_user_otp_email(user.email, otp_code)

                    session["pending_user"] = username
                    session["otp_sent"] = True

                    return redirect("/verify-otp")

                # ƒêƒÉng nh·∫≠p th√†nh c√¥ng
                user.online = True
                user.last_seen = datetime.utcnow()

                session["username"] = user.username
                session["user_id"] = user.user_id  # d√πng UUID
                session["vip_until_gpt"] = user.vip_until_gpt
                session["al_uses"] = 0  # l∆∞·ª£t AI Lite t·∫°m

                db.session.commit()

                if user.vip_gpt_ai:
                    session["just_logged_in"] = True

                print("[DEBUG] ƒêƒÉng nh·∫≠p th√†nh c√¥ng:", username)
                return redirect(url_for("home_page"))

        return render_template("login.html", error="‚ùå Sai t√†i kho·∫£n ho·∫∑c m·∫≠t kh·∫©u.")

    return render_template("login.html", message=message)


@app.route("/register", methods=["GET", "POST"])
def register():
    if request.method == "POST":
        ip = request.remote_addr

        if session.get("username") != "admin":
            count = record_ip(ip)
            if count >= 3:
                message = f"""
<b>C·∫£nh b√°o ƒëƒÉng k√Ω SPAM</b>
üî¢ IP: <code>{ip}</code>
üïí Ng√†y: {datetime.now().strftime('%Y-%m-%d')}
üí• S·ªë l·∫ßn t·∫°o t√†i kho·∫£n: {count} (h·∫°n m·ª©c: 3)
                """
                send_telegram_message(message.strip())
        fullname = request.form.get("fullname", "").strip()
        username = request.form.get("username", "").strip().lower()
        email = request.form.get("email", "").strip()
        password = request.form.get("password")
        confirm_password = request.form.get("confirm_password")
        want_verification = 'want_verification' in request.form

        if username == "admin":
            return render_template("register.html", error="üö´ Kh√¥ng ƒë∆∞·ª£c ƒë·∫∑t t√™n t√†i kho·∫£n l√† 'admin'.")

        if len(password) < 8:
            return render_template("register.html", error="‚ùå M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 8 k√Ω t·ª±.")
        if not re.search(r"[A-Z]", password):
            return render_template("register.html", error="‚ùå M·∫≠t kh·∫©u ph·∫£i ch·ª©a √≠t nh·∫•t 1 ch·ªØ in hoa.")
        if not re.search(r"[a-z]", password):
            return render_template("register.html", error="‚ùå M·∫≠t kh·∫©u ph·∫£i ch·ª©a √≠t nh·∫•t 1 ch·ªØ th∆∞·ªùng.")
        if not re.search(r"[0-9]", password):
            return render_template("register.html", error="‚ùå M·∫≠t kh·∫©u ph·∫£i ch·ª©a √≠t nh·∫•t 1 ch·ªØ s·ªë.")
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
            return render_template("register.html", error="‚ùå M·∫≠t kh·∫©u ph·∫£i ch·ª©a √≠t nh·∫•t 1 k√Ω t·ª± ƒë·∫∑c bi·ªát.")
        if password != confirm_password:
            return render_template("register.html", error="‚ùå M·∫≠t kh·∫©u x√°c nh·∫≠n kh√¥ng kh·ªõp.")

        existing_user = User.query.filter_by(username=username).first()
        if existing_user:
            return render_template("register.html", error="‚ùå T√™n ƒëƒÉng nh·∫≠p ƒë√£ t·ªìn t·∫°i.")

        new_user = User(
            username=username,
            password=password,
            fullname=fullname, 
            email=email,
            is_verified=False,
            wants_verification=want_verification,
            free_gpt_uses=5
        )

        db.session.add(new_user)
        db.session.commit()
        return redirect("/login")

    return render_template("register.html")

#TH√îNG TIN T√ÄI KHO·∫¢N C√Å NH√ÇN T·ª™NG USER
from models.user import User
from extensions import db

@app.route("/user-info", methods=["GET", "POST"])
def user_info():
    username = session.get("username")
    if not username:
        return redirect("/login")

    user = User.query.filter_by(username=username).first()
    if not user:
        return redirect("/login")

    if request.method == "POST":
        # üëá L·∫•y d·ªØ li·ªáu t·ª´ form g·ª≠i l√™n
        email = request.form.get("email")
        password = request.form.get("new_password")
        fullname = request.form.get("fullname")
        birthday = request.form.get("birthday")
        birthyear = request.form.get("birthyear")
        phone = request.form.get("phone")


        # üëá C·∫≠p nh·∫≠t n·∫øu c√≥
        if email: user.email = email
        if password: user.password = password
        if fullname: user.fullname = fullname
        if birthday: user.birthday = birthday
        if birthyear: user.birthyear = birthyear
        if phone: user.phone = phone


        # üëá X·ª≠ l√Ω avatar upload
        avatar = request.files.get("avatar")
        if avatar and avatar.filename != "":
            filename = secure_filename(f"{username}_avatar.png")
            avatar_path = os.path.join("static/images/avatars", filename)
            avatar.save(avatar_path)
            user.avatar_url = f"/static/images/avatars/{filename}"
            print("‚úÖ ƒê√É G√ÅN AVATAR URL:", user.avatar_url)
        else:
            print("‚ùå KH√îNG NH·∫¨N FILE ·∫¢NH")

        db.session.commit()
        print("üî• USER SAU L∆ØU:", user)

        flash("ƒê√£ c·∫≠p nh·∫≠t th√¥ng tin th√†nh c√¥ng!", "success")
        return redirect("/user-info")

    return render_template("user_info.html", user=user, username=user.username,now=datetime.now())


#X√ìA AVTR
@app.route("/user-info/delete-avatar", methods=["POST"])
def delete_avatar():
    username = session.get("username")
    if not username:
        return redirect("/login")

    user = User.query.filter_by(username=username).first()
    if not user:
        return redirect("/login")

    if user.avatar_url and user.avatar_url != "/static/logos/logo.png":
        try:
            os.remove(user.avatar_url.replace("/", os.sep)[1:])
        except:
            pass
    user.avatar_url = "/static/logos/logo.png"

    db.session.commit()

    flash("·∫¢nh ƒë·∫°i di·ªán ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t l·∫°i v·ªÅ m·∫∑c ƒë·ªãnh!", "info")
    return redirect("/user-info")

#========ROUTE X√ÅC TH·ª∞C T√ÄI KHO·∫¢N==========#
@app.route("/verify-otp", methods=["GET", "POST"])
def verify_otp():
    username = session.get("pending_user") or session.get("username")
    if not username:
        return redirect(url_for("login"))

    user = User.query.filter_by(username=username).first()
    if not user:
        return redirect(url_for("login"))

    if user.is_verified:
        return redirect(url_for("home_page"))

    # ‚úÖ G·ª≠i OTP n·∫øu ch∆∞a g·ª≠i
    if request.method == "GET":
        if not getattr(user, "otp_code", None) or not session.get("otp_sent"):
            import random
            otp = str(random.randint(100000, 999999))
            user.otp_code = otp
            db.session.commit()

            # ‚úÖ G·ª≠i t·ªõi email_temp n·∫øu ƒëang ƒë·ªïi email, ng∆∞·ª£c l·∫°i g·ª≠i v·ªÅ email ch√≠nh
            email_to_send = user.email_temp if user.email_temp else user.email
            success = send_user_otp_email(email_to_send, otp)

            if success:
                print(f"‚úÖ ƒê√£ g·ª≠i OTP t·ªõi {email_to_send}")
            else:
                print(f"‚ùå G·ª≠i OTP th·∫•t b·∫°i t·ªõi {email_to_send}")

            session["otp_sent"] = True

        return render_template(
            "verify_otp.html",
            username=username,
            method="email",
            error="",
            user=user
        )

    # ‚úÖ X·ª≠ l√Ω nh·∫≠p m√£ OTP
    if request.method == "POST":
        otp_input = request.form.get("otp")
        if otp_input == user.otp_code:
            user.is_verified = True
            user.otp_code = None

            # ‚úÖ N·∫øu ƒëang trong qu√° tr√¨nh ƒë·ªïi email th√¨ c·∫≠p nh·∫≠t email m·ªõi
            if user.email_temp and user.email_temp != user.email:
                print(f"üì© ƒê·ªïi email t·ª´ {user.email} ‚ûú {user.email_temp}")
                user.email = user.email_temp
                user.email_temp = None

            # ‚úÖ T·∫∑ng th√™m l∆∞·ª£t n·∫øu ch·ªâ m·ªõi c√≥ 5
            if (user.free_gpt_uses or 0) <= 5:
                user.free_gpt_uses = (user.free_gpt_uses or 0) + 10

            db.session.commit()

            session["username"] = username
            session["user_id"] = user.id
            session["is_verified"] = True
            session.pop("pending_user", None)
            session.pop("otp_sent", None)

            for key in ["chat_history", "chat_ai_lite", "chat_ai_lite_history"]:
                session.pop(key, None)

            session["just_verified"] = True
            session.modified = True

            return redirect(url_for("home_page"))

        # ‚ùå Sai OTP
        return render_template(
            "verify_otp.html",
            username=username,
            method="email",
            error="‚ùå Sai m√£ OTP. Vui l√≤ng th·ª≠ l·∫°i.",
            user=user
        )

    return render_template(
        "verify_otp.html",
        username=username,
        method="email",
        error="",
        user=user
    )

@app.route("/resend-otp", methods=["POST"])
def resend_otp():
    username = session.get("pending_user") or session.get("username")
    print("Resending OTP for:", username)

    if not username:
        return Response(json.dumps({
            "status": "error",
            "message": "‚ùå Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n."
        }, ensure_ascii=False), content_type="application/json")

    user = User.query.filter_by(username=username).first()
    if not user:
        return Response(json.dumps({
            "status": "error",
            "message": "‚ùå Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n."
        }, ensure_ascii=False), content_type="application/json")

    email = user.email
    otp = str(random.randint(100000, 999999))
    print("Generated OTP:", otp)

    user.otp_code = otp
    db.session.commit()

    success = send_user_otp_email(email, otp)

    if success:
        return Response(json.dumps({
            "status": "ok",
            "message": "‚úÖ ƒê√£ g·ª≠i l·∫°i m√£ x√°c th·ª±c qua email."
        }, ensure_ascii=False), content_type="application/json")
    else:
        return Response(json.dumps({
            "status": "error",
            "message": "‚ùå G·ª≠i email th·∫•t b·∫°i. Vui l√≤ng th·ª≠ l·∫°i sau."
        }, ensure_ascii=False), content_type="application/json")

@app.route("/logout")
def logout():
    username = session.get("username")

    if username:
        user = User.query.filter_by(username=username).first()
        if user:
            user.online = False
            db.session.commit()

    # T√°ch ri√™ng cho t·ª´ng lo·∫°i session
    if session.get("admin"):
        session.pop("admin", None)
        return redirect("/admin_login")

    session.pop("username", None)
    session.pop("user_id", None)
    return redirect("/login")

#KH√îI PH·ª§C T√ÄI KHO·∫¢N 
@app.route("/forgot-password", methods=["GET", "POST"])
def forgot_password():
    if request.method == "POST":
        input_text = request.form["username"].strip().lower()

        # ‚úÖ T√¨m user theo username ho·∫∑c email (kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng)
        user = User.query.filter(
            (User.username.ilike(input_text)) | (User.email.ilike(input_text))
        ).first()

        if not user:
            return render_template("forgot_password.html", error="T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i.")

        if not user.is_verified:
            return render_template("forgot_password.html", error="Ch·ª©c nƒÉng n√†y ch·ªâ h·ªó tr·ª£ t√†i kho·∫£n ƒë√£ x√°c th·ª±c.")

        # ‚úÖ G·ª≠i OTP
        otp_code = generate_otp()
        send_user_otp_email(user.email, otp_code)

        otp_data = load_otp_data()
        otp_data[user.username] = otp_code
        save_otp_data(otp_data)

        session["reset_user"] = user.username
        return redirect("/reset-password")

    return render_template("forgot_password.html")

@app.route("/change-email", methods=["GET", "POST"])
def change_email():
    username = session.get("username")
    if not username:
        return redirect("/login")

    user = User.query.filter_by(username=username).first()
    if not user:
        return redirect("/login")

    # ‚ö†Ô∏è Ch·ªâ cho ƒë·ªïi n·∫øu ƒë√£ x√°c th·ª±c email tr∆∞·ªõc ƒë√≥
    if not user.is_verified:
        flash("B·∫°n c·∫ßn x√°c th·ª±c email tr∆∞·ªõc khi ƒë·ªïi!", "danger")
        return redirect("/user-info")

    if request.method == "POST":
        new_email = request.form.get("new_email")

        if not new_email or "@" not in new_email:
            flash("Email kh√¥ng h·ª£p l·ªá!", "danger")
            return redirect("/change-email")

        # ‚úÖ Ghi th√¥ng tin t·∫°m, ch∆∞a c·∫≠p nh·∫≠t vƒ©nh vi·ªÖn
        user.email_temp = new_email
        user.is_verified = False
        user.otp_code = generate_otp()

        db.session.commit()

        # ‚úÖ G·ª≠i m√£ x√°c th·ª±c t·ªõi email m·ªõi
        send_otp_email(new_email, user.otp_code)

        flash("ƒê√£ g·ª≠i m√£ x√°c nh·∫≠n ƒë·∫øn email m·ªõi! Vui l√≤ng ki·ªÉm tra v√† x√°c th·ª±c l·∫°i.", "info")
        return redirect("/verify-otp")

    return render_template("change_email.html")

@app.route("/reset-password", methods=["GET", "POST"])
def reset_password():
    session_username = session.get("reset_user")
    if not session_username:
        return redirect("/forgot-password")

    # ‚úÖ Chu·∫©n h√≥a session_username ngay t·ª´ ƒë·∫ßu
    session_username = session_username.strip().lower()

    if request.method == "POST":
        input_username = request.form["username"].strip().lower()
        otp = request.form["otp"].strip()
        new_password = request.form["new_password"]
        confirm = request.form["confirm_password"]

        # ‚úÖ So kh·ªõp username
        if input_username != session_username:
            return render_template("reset_password.html", error="‚ö†Ô∏è T√™n t√†i kho·∫£n kh√¥ng kh·ªõp.")

        # ‚úÖ So kh·ªõp OTP
        otp_data = load_otp_data()
        if otp_data.get(session_username) != otp:
            return render_template("reset_password.html", error="‚ö†Ô∏è M√£ OTP kh√¥ng ƒë√∫ng.")

        # ‚úÖ Ki·ªÉm tra m·∫≠t kh·∫©u
        if new_password != confirm:
            return render_template("reset_password.html", error="‚ö†Ô∏è M·∫≠t kh·∫©u x√°c nh·∫≠n kh√¥ng kh·ªõp.")

        if len(new_password) < 8:
            return render_template("reset_password.html", error="‚ö†Ô∏è M·∫≠t kh·∫©u ph·∫£i t·ª´ 8 k√Ω t·ª± tr·ªü l√™n.")

        # ‚úÖ C·∫≠p nh·∫≠t m·∫≠t kh·∫©u
        user = User.query.filter_by(username=session_username).first()
        if not user:
            return render_template("reset_password.html", error="‚ö†Ô∏è T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i.")

        user.password = new_password
        user.online = True
        db.session.commit()

        # ‚úÖ Xo√° OTP & session
        otp_data.pop(session_username, None)
        save_otp_data(otp_data)
        session.pop("reset_user", None)

        # ‚úÖ T·ª± ƒëƒÉng nh·∫≠p l·∫°i
        session["username"] = user.username
        session["user_id"] = user.user_id
        session["vip_until_gpt"] = user.vip_until_gpt
        session["vip_ai_lite"] = user.vip_ai_lite
        session["vip_until_lite"] = user.vip_until_lite or ""
        session["al_uses"] = 0

        return redirect("/")

    return render_template("reset_password.html")

@app.route("/change-password", methods=["GET", "POST"])
def change_password():
    username = session.get("username")
    if not username:
        return redirect("/login")

    user = User.query.filter_by(username=username).first()
    if not user:
        return redirect("/login")
    avatar_url = user.avatar_url or "/static/logos/logo.png"
    if request.method == "POST":
     
        current_password = request.form.get("current_password")
        new_password = request.form.get("new_password")
        confirm_password = request.form.get("confirm_password")

        if user.password != current_password:
            return render_template("change_password.html", error="‚ö†Ô∏è M·∫≠t kh·∫©u hi·ªán t·∫°i kh√¥ng ƒë√∫ng.")

        if new_password != confirm_password:
            return render_template("change_password.html", error="‚ö†Ô∏è M·∫≠t kh·∫©u x√°c nh·∫≠n kh√¥ng kh·ªõp.")

        if len(new_password) < 8:
            return render_template("change_password.html", error="‚ö†Ô∏è M·∫≠t kh·∫©u ph·∫£i t·ª´ 8 k√Ω t·ª± tr·ªü l√™n.")

        user.password = new_password
        db.session.commit()

        return redirect("/")

    return render_template("change_password.html", avatar_url=avatar_url)



# TRANG CH·ª¶
from sqlalchemy import distinct
from models import Message, User  # ƒë·∫£m b·∫£o ƒë√£ import model Message

@app.route("/")
def home_page():
    if is_maintenance("home"):
        return render_template("maintenance.html")

    username = session.get("username")
    if not username:
        return redirect("/login")

    user = User.query.filter_by(username=username).first()
    if not user:
        print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y user trong database.")
        if not session.get("reloading_after_restore"):
            session["reloading_after_restore"] = True
            time.sleep(0.3)
            return redirect("/")
        else:
            session.pop("reloading_after_restore", None)
            return render_template("login.html", error="‚ö†Ô∏è D·ªØ li·ªáu t√†i kho·∫£n kh√¥ng t·ªìn t·∫°i. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.")

    # ‚úÖ ƒê√£ c√≥ user
    session.pop("reloading_after_restore", None)

    if user.is_blocked:
        session.clear()
        return render_template("login.html", error="üö´ T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã kh√≥a...")
    user_messages = []

    # ‚úÖ L·∫•y danh s√°ch ng∆∞·ªùi ƒë√£ g·ª≠i tin ch∆∞a ƒë·ªçc
    unread_senders = (
        db.session.query(distinct(Message.sender))
        .filter(Message.receiver == user.username, Message.read == False)
        .all()
    )
    sender_usernames = [
            sender_id[0]
            for sender_id in unread_senders
            if sender_id[0] != user.username
        ]


    user_vip_status = {
        "vip_gpt": user.vip_gpt_ai,
        "vip_lite": user.vip_ai_lite,
        "vip_until_gpt": user.vip_until_gpt or "",
        "vip_until_lite": user.vip_until_lite or ""
    }

    display_name = user.fullname or username
    avatar_url = user.avatar_url or "/static/logos/logo.png"

    session.pop("just_logged_in", None)

    has_slv = bool(user.vip_gpt_ai) and bool(user.vip_until_gpt)
    return render_template(
        "home.html",
        username=username,
        avatar_url=avatar_url,
        display_name=display_name,
        has_slv=has_slv,
        user=user,
        user_vip_status=user_vip_status,
        user_messages=user_messages,
        user_unread_senders=sender_usernames,  # ‚úÖ truy·ªÅn xu·ªëng template
        is_maintenance=is_maintenance("home"),
    )


#T·ªîNG QU√ÅT
from flask import render_template, request, session, redirect, abort
import os
from datetime import datetime

login_attempts = {}

@app.route("/solverviet_control_x2025")
@admin_only
def admin_panel():
    print("üëÅ Session hi·ªán t·∫°i:", dict(session))
    return render_template("admin.html")

import pyotp
import os
from flask import Flask, request, session, redirect, render_template

# ---- Route 1: admin_login - ki·ªÉm tra 4 tr∆∞·ªùng ----
@app.route("/admin_login", methods=["GET", "POST"])
def admin_login():
    ip = request.remote_addr
    login_attempts.setdefault(ip, 0)

    if login_attempts[ip] >= 5:
        return "‚ö†Ô∏è B·∫°n ƒë√£ nh·∫≠p sai qu√° nhi·ªÅu l·∫ßn. Vui l√≤ng th·ª≠ l·∫°i sau.", 429

    if request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")
        code1 = request.form.get("backdoor_code")
        code2 = request.form.get("backdoor_code2")

        ADMIN_USERNAME = os.getenv("ADMIN_USERNAME")
        ADMIN_PASSWORD = os.getenv("ADMIN_PASSWORD")
        BACKDOOR_CODE = os.getenv("BACKDOOR_CODE")
        BACKDOOR_CODE2 = os.getenv("BACKDOOR_CODE2")
        if (username == ADMIN_USERNAME and password == ADMIN_PASSWORD and
            code1 == BACKDOOR_CODE and code2 == BACKDOOR_CODE2):
            session["admin_otp_ready"] = True
            print("‚úÖ Th√¥ng tin h·ª£p l·ªá. Session hi·ªán t·∫°i:", dict(session))
            return "OK"  # G·ª≠i v·ªÅ frontend ƒë·ªÉ hi·ªÉn popup nh·∫≠p OTP
        else:
            login_attempts[ip] += 1
            return "‚ùå C√ì CC N√à M√Ä ƒê√íI V√î", 403

    return render_template("admin_login.html")

@app.route("/admin_2fa", methods=["POST"])
def admin_2fa():
    if not session.get("admin_otp_ready"):
        return "Phi√™n x√°c th·ª±c kh√¥ng h·ª£p l·ªá.", 403

    code = request.form.get("otp", "").strip()
    secret = os.getenv("ADMIN_2FA_SECRET")

    if not secret:
        return "‚ùå SECRET kh√¥ng t·ªìn t·∫°i", 500

    totp = pyotp.TOTP(secret)

    if totp.verify(code, valid_window=1):
        session.pop("admin_otp_ready", None)
        session["is_admin"] = True
        return redirect("/solverviet_control_x2025")
    else:
        return "‚ùå M√£ x√°c th·ª±c sai", 403




#XEM QU·∫¢NG C√ÅO
@app.route("/watch_ad", methods=["POST"])
def watch_ad():
    username = get_username()
    if not username:
        return {"status": "fail", "message": "Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n!"}

    user = User.query.filter_by(username=username).first()
    if not user:
        return {"status": "fail", "message": "Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n!"}

    today = get_today()
    if user.last_solve_date != today:
        user.last_solve_date = today
        user.solves = 0
        user.ads_used_today = False

    if not user.ads_used_today:
        user.solves = max(0, user.solves - 3)
        user.ads_used_today = True
        db.session.commit()
        return {"status": "success", "message": "+3 l∆∞·ª£t mi·ªÖn ph√≠"}
    else:
        return {"status": "fail", "message": "B·∫°n ƒë√£ nh·∫≠n qu·∫£ng c√°o h√¥m nay r·ªìi!"}
@app.route("/verify_user_info", methods=["POST"])
def verify_user_info():
    data = request.get_json()
    username = data.get("username", "").strip()
    user_id = data.get("user_id", "").strip()
    user = User.query.filter_by(username=username, user_id=user_id).first()
    return jsonify({"valid": bool(user)})
def send_upgrade_email(to_email, username, package, amount, method, note, created_at, txn_id):
    from flask import url_for
    import os
    import smtplib
    from email.mime.multipart import MIMEMultipart
    from email.mime.text import MIMEText

    email_user = os.getenv("EMAIL_ADDRESS")
    email_pass = os.getenv("EMAIL_PASSWORD")
    BASE_URL = os.getenv("BASE_URL", "http://127.0.0.1:5000")
    approve_link = f"{BASE_URL}{url_for('admin_review')}?txn_id={txn_id}&email=phatth.viettel@gmail.com"


    print("üìß LINK EMAIL:", approve_link)

    msg = MIMEMultipart()
    msg['From'] = email_user
    msg['To'] = to_email
    msg['Subject'] = "üîî Y√™u c·∫ßu n√¢ng c·∫•p g√≥i m·ªõi t·ª´ ng∆∞·ªùi d√πng"

    body = f"""
    <h3>üîî Y√™u c·∫ßu n√¢ng c·∫•p m·ªõi</h3>
    <p><b>üë§ User:</b> {username}</p>
    <p><b>üí≥ G√≥i:</b> {package} ({amount})</p>
    <p><b>üè¶ Ph∆∞∆°ng th·ª©c:</b> {method}</p>
    <p><b>üìù Ghi ch√∫:</b> {note}</p>
    <p><b>üïí Th·ªùi gian:</b> {created_at.strftime('%Y-%m-%d %H:%M:%S')}</p>
    <br>
    <p>‚û°Ô∏è <b>Link duy·ªát:</b> <a href="{approve_link}" target="_blank">{approve_link}</a></p>
    <p>üìã Ho·∫∑c copy th·ªß c√¥ng: {approve_link}</p>
    """

    msg.attach(MIMEText(body, 'html'))

    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
            server.login(email_user, email_pass)
            server.send_message(msg)
        print("‚úÖ ƒê√£ g·ª≠i email n√¢ng c·∫•p t·ªõi admin.")
    except Exception as e:
        print("‚ùå G·ª≠i email n√¢ng c·∫•p l·ªói:", e)



@app.route("/upgrade", methods=["GET", "POST"])
def upgrade():
    username = session.get("username")
    if not username:
        return redirect(url_for("login"))

    if request.method == "POST":
        package = request.form["package"]
        note = request.form["note"]
        method = request.form.get("method", "Kh√¥ng r√µ")

        if not note.strip():
            return render_template("upgrade.html", error="‚ö†Ô∏è Vui l√≤ng nh·∫≠p m√£ giao d·ªãch ho·∫∑c ghi ch√∫.")

        user = User.query.filter_by(username=username).first()
        if not user:
            return render_template("upgrade.html", error="‚ùå Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n.")

        now = now_vn()
        has_gpt = user.vip_until_gpt and user.vip_until_gpt > now
        has_lite = user.vip_until_lite and user.vip_until_lite > now

        if package.startswith("vip_gpt") and has_lite:
            return render_template("upgrade.html", error="üö´ B·∫°n ƒëang d√πng g√≥i AI Lite. Kh√¥ng th·ªÉ mua th√™m g√≥i GPT c√πng l√∫c.")
        if package == "vip_ai_lite" and has_gpt:
            return render_template("upgrade.html", error="üö´ B·∫°n ƒëang d√πng g√≥i GPT. Kh√¥ng th·ªÉ mua th√™m g√≥i AI Lite c√πng l√∫c.")

        # ‚úÖ T·∫°o ID giao d·ªãch
        created_at = now
        txn_id = f"txn_{int(now.timestamp())}_{random.randint(1000,9999)}"
        session["last_txn_id"] = txn_id  # ƒë·ªÉ ki·ªÉm tra b·∫±ng /check_status

        # Hi·ªÉn th·ªã g√≥i
        package_display = {
            "vip_gpt_5d": "49K",
            "vip_gpt_15d": "109K",
            "vip_gpt_30d": "149K",
            "vip_ai_lite": "25K"
        }
        amount = package_display.get(package, "Kh√¥ng r√µ")

        # ‚úÖ L∆∞u v√†o DB
        txn = Transaction(
            txn_id=txn_id,
            username=username,
            amount=amount,
            package=package,
            method=method,
            note=note,
            status="pending",
            created_at=created_at
        )
        db.session.add(txn)
        db.session.commit()

        # ‚úÖ G·ª≠i email cho admin
        try:
            send_upgrade_email(
                to_email=os.getenv("ADMIN_EMAIL"),
                username=username,
                package=package,
                amount=amount,
                method=method,
                note=note,
                created_at=created_at,
                txn_id=txn_id 
            )
        except Exception as e:
            print("‚ùå G·ª≠i email n√¢ng c·∫•p l·ªói:", e)

        # ‚úÖ G·ª≠i Telegram n·∫øu b·∫°n v·∫´n mu·ªën d√πng
        try:
            send_telegram_message(
                f"üîî <b>Y√™u c·∫ßu n√¢ng c·∫•p m·ªõi</b>\n"
                f"üë§ User: <code>{username}</code>\n"
                f"üí≥ G√≥i: {package} ({amount})\n"
                f"üè¶ Ph∆∞∆°ng th·ª©c: {method}\n"
                f"üìù Ghi ch√∫: <code>{note}</code>\n"
                f"üïí Th·ªùi gian: {created_at.strftime('%Y-%m-%d %H:%M:%S')}\n"
                f"‚û°Ô∏è V√†o trang admin ƒë·ªÉ duy·ªát: {url_for('admin_review', _external=True)}"
            )
        except:
            pass

        # Tr·∫£ v·ªÅ giao di·ªán th√†nh c√¥ng
        return render_template(
            "upgrade.html",
            success=True,
            txn_id=txn_id,
            flash_message="‚úÖ Giao d·ªãch ƒë√£ ƒë∆∞·ª£c ghi nh·∫≠n! B·∫°n s·∫Ω ƒë∆∞·ª£c duy·ªát trong v√≤ng 5 ph√∫t."
        )

    # GET
    user = User.query.filter_by(username=username).first()
    display_name = user.fullname if user and user.fullname else username

    now = now_vn()
    vip_gpt_active = user.vip_until_gpt and user.vip_until_gpt > now
    vip_lite_active = user.vip_until_lite and user.vip_until_lite > now

    return render_template(
        "upgrade.html",
        fullname=display_name,
        user_id=user.user_id if user else "",
        vip_gpt_active=vip_gpt_active,
        vip_lite_active=vip_lite_active
    )


from flask import jsonify
import logging
log = logging.getLogger('werkzeug')

@app.route("/check_status")
def check_status():
    log.setLevel(logging.ERROR)  # ·∫®n b·ªõt log spam
    txn_id = session.get("last_txn_id")

    if not txn_id:
        return jsonify({"status": "none"})

    from models.transaction import Transaction
    txn = Transaction.query.filter_by(txn_id=txn_id).first()

    if txn:
        return jsonify({
            "status": txn.status,
            "package": txn.package,
            "method": txn.method,
            "created_at": txn.created_at.strftime("%Y-%m-%d %H:%M:%S")
        })
    else:
        return jsonify({"status": "not_found"})

def grant_vip(username, package, method=""):
    print(f"‚ö†Ô∏è [grant_vip] C·∫•p g√≥i: {package} cho user: {username}")

    user = User.query.filter_by(username=username).first()
    if not user:
        print("‚ùå Kh√¥ng t√¨m th·∫•y user:", username)
        return "‚ùå Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i."

    now = datetime.utcnow()
    message = "‚úÖ G√≥i ƒë√£ ƒë∆∞·ª£c c·∫•p th√†nh c√¥ng!"

    gpt_vip_until = user.vip_until_gpt or now
    lite_vip_until = user.vip_until_lite or now

    # ‚úÖ G√≥i GPT
    if package in ["vip_gpt_5d", "vip_gpt_15d", "vip_gpt_30d"]:
        if lite_vip_until > now:
            return "‚ùå B·∫°n ƒëang c√≥ g√≥i  Lite. Kh√¥ng th·ªÉ mua g√≥i SLV. Vui l√≤ng ƒë·ª£i h·∫øt h·∫°n ho·∫∑c li√™n h·ªá nh√† ph√°t tri·ªÉn."

        if gpt_vip_until > now:
            print("‚ö†Ô∏è ƒêang ghi ƒë√® g√≥i GPT hi·ªán t·∫°i b·∫±ng g√≥i m·ªõi")

        days_map = {
            "vip_gpt_5d": (5, "5day"),
            "vip_gpt_15d": (15, "15day"),
            "vip_gpt_30d": (30, "30day")
        }
        duration, gpt_type = days_map[package]
        user.vip_gpt_ai = True
        user.vip_gpt = gpt_type
        new_vip = (now + timedelta(days=duration)).replace(hour=23, minute=59, second=59, microsecond=0)
        user.vip_until_gpt = new_vip

        if gpt_type == "5day":
            user.gpt_usage_today = 0
            user.gpt_usage_date = now.strftime("%Y-%m-%d")
            user.gpt_unlimited = False

        # G·ª° g√≥i Lite n·∫øu c√≥
        user.vip_until_lite = None
        user.vip_ai_lite = None
        user.vip_lite_daily_limit = None
        user.lite_usage = None
        user.lite_date = None

    # ‚úÖ G√≥i AI Lite
    elif package == "vip_ai_lite":
        if gpt_vip_until > now:
            return "‚ùå B·∫°n ƒëang c√≥ g√≥i SLV. Kh√¥ng th·ªÉ mua g√≥i Lite. Vui l√≤ng ƒë·ª£i h·∫øt h·∫°n ho·∫∑c li√™n h·ªá nh√† ph√°t tri·ªÉn."

        if lite_vip_until > now:
            print("‚ö†Ô∏è G√≥i Lite hi·ªán t·∫°i v·∫´n c√≤n hi·ªáu l·ª±c. S·∫Ω ghi ƒë√® l·∫°i b·∫±ng g√≥i m·ªõi.")

        # Reset l·∫°i g√≥i Lite (ghi ƒë√® t·ª´ b√¢y gi·ªù + 7 ng√†y)
        new_vip = (now + timedelta(days=7)).replace(hour=23, minute=59, second=59, microsecond=0)
        user.vip_ai_lite = True
        user.vip_until_lite = new_vip
        user.vip_lite_daily_limit = 50
        user.lite_usage = 0
        user.lite_date = now.strftime("%Y-%m-%d")

    else:
        return "‚ùå G√≥i kh√¥ng h·ª£p l·ªá."

    try:
        db.session.commit()
        print("‚úÖ ƒê√£ l∆∞u d·ªØ li·ªáu ng∆∞·ªùi d√πng.")
        return message
    except Exception as e:
        db.session.rollback()
        print("‚ùå L·ªói khi l∆∞u:", e)
        return "‚ùå L·ªói khi l∆∞u d·ªØ li·ªáu."


#N√öT ADMIN DUY·ªÜT
@app.route("/admin/review")
@admin_only
def admin_review():
    txs = Transaction.query.filter_by(status="pending").order_by(Transaction.created_at.desc()).all()
    return render_template("admin_review.html", txs=txs)
@app.route("/admin/review/requests")
@admin_only
def get_review_requests():
    txs = Transaction.query.filter_by(status="pending").order_by(Transaction.created_at.desc()).all()
    return render_template("admin/_requests_table.html", txs=txs)


@app.route("/admin/approve/<txn_id>")
@admin_only
def approve_transaction(txn_id):
    tx = Transaction.query.filter_by(txn_id=txn_id, status="pending").first()
    if not tx:
        return redirect(url_for("admin_review"))

    tx.status = "approved"
    db.session.commit()

    package = normalize_package(tx.package)
    method = tx.method
    username = tx.username

    result = grant_vip(username, package, method)

    if isinstance(result, str) and result.startswith("‚ùå"):
        print(f"[‚ùå] L·ªói khi c·∫•p g√≥i: {result}")
    else:
        print(f"[‚úÖ] G√≥i {package} ƒë√£ ƒë∆∞·ª£c c·∫•p cho {username} th√†nh c√¥ng.")

    return redirect(url_for("admin_review"))

@app.route("/admin/reject/<txn_id>")
@admin_only
def reject_transaction(txn_id):
    tx = Transaction.query.filter_by(txn_id=txn_id, status="pending").first()
    if not tx:
        return redirect(url_for("admin_review"))

    tx.status = "rejected"
    db.session.commit()
    return redirect(url_for("admin_review"))

def is_follow_up(msg):
    msg = msg.lower().strip()
    follow_keywords = ["b√†i", "ph·∫ßn", "ti·∫øp", "ti·∫øp theo", "ti·∫øp t·ª•c", "r·ªìi sao", "c√¢u", "n·ªØa", "b nh√©", "c th√¨ sao"]
    return any(kw in msg for kw in follow_keywords) and len(msg.split()) <= 6


#CHO LATEX ƒê·∫∏P OCR NH·∫¨N DI·ªÜN T·ªêT NH·∫§T C√ì TH·ªÇ
def clean_ocr_output(text):
    # Chu·∫©n h√≥a unicode: t√°ch c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát th√†nh k√Ω t·ª± chu·∫©n
    text = unicodedata.normalize("NFC", text)

    # X√≥a k√Ω t·ª± v√¥ nghƒ©a, gi·ªØ l·∫°i k√Ω hi·ªáu to√°n h·ªçc
    text = re.sub(r"[^\w\s=+\-*/^().œÄlim‚Üí\n]", "", text)

    # Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a
    text = re.sub(r"\s+", " ", text)

    # S·ª≠a l·ªói OCR sai ch·ªØ ‚Üí s·ªë
    text = text.replace("O", "0")
    text = text.replace("l", "1")
    text = text.replace("I", "1")

    # S·ª≠a l·ªói OCR sai nh√¢n/x
    text = text.replace("√ó", "*").replace("x", "x").replace("X", "x")

    # S·ª≠a l·ªói to√°n h·ªçc th∆∞·ªùng g·∫∑p
    fixes = {
        "32 - 7": "3x - 7",
        "22 + 5": "2x + 5",
        "x2": "x^2",
        "x 2": "x^2",
        "x¬≤": "x^2",
        "lim x2": "lim x‚Üí2",
        "Lim x2": "lim x‚Üí2",
        "lim x‚Üí": "lim x‚Üí2",
        "œÄ r 2": "œÄr^2",
        "œÄ r^ 2": "œÄr^2"
    }
     
    for wrong, right in fixes.items():
        text = text.replace(wrong, right)

    # X√≥a kho·∫£ng tr·∫Øng d∆∞ ƒë·∫ßu/cu·ªëi
    return text.strip()
#=====B·∫†N B√à=====#
@app.route("/unblock_user", methods=["POST"])
def unblock_user():
    username = session.get("username")
    data = request.get_json()
    target = data.get("target")

    if not username or not target:
        return jsonify({"status": "error", "message": "Thi·∫øu d·ªØ li·ªáu"})

    user = User.query.filter_by(username=username).first()
    target_user = User.query.filter_by(username=target).first()

    if not user or not target_user:
        return jsonify({"status": "error", "message": "Kh√¥ng t√¨m th·∫•y user"})

    # üëá Gi·∫£ s·ª≠ c√≥ user.blocked_users l√† relationship list
    if target_user in user.blocked_users:
        user.blocked_users.remove(target_user)
        db.session.commit()
        return jsonify({"status": "success"})

    return jsonify({"status": "error", "message": "User ch∆∞a b·ªã ch·∫∑n"})

@app.route("/blocked_users")
def get_blocked_users():
    username = session.get("username")
    if not username:
        return jsonify([])

    user = User.query.filter_by(username=username).first()
    if not user:
        return jsonify([])

    blocked_list = [u.username for u in user.blocked_users]
    return jsonify(blocked_list)


@app.route("/block_user", methods=["POST"])
def block_user():
    username = session.get("username")
    data = request.get_json()
    target = data.get("target")

    if not username or not target:
        return jsonify({"status": "error", "message": "Thi·∫øu d·ªØ li·ªáu"})

    user = User.query.filter_by(username=username).first()
    target_user = User.query.filter_by(username=target).first()

    if not user or not target_user:
        return jsonify({"status": "error", "message": "User kh√¥ng t·ªìn t·∫°i"})

    if target_user not in user.blocked_users:
        user.blocked_users.append(target_user)
        db.session.commit()

    return jsonify({"status": "success"})


@app.route("/chat/delete/<friend>", methods=["POST"])
def delete_chat(friend):
    username = session.get("username")
    if not username:
        return jsonify({"success": False, "error": "Ch∆∞a ƒëƒÉng nh·∫≠p"})

    from models.message import Message

    msgs = Message.query.filter(
        db.or_(
            db.and_(Message.sender == username, Message.receiver == friend),
            db.and_(Message.sender == friend, Message.receiver == username)
        )
    ).all()

    if not msgs:
        return jsonify({"success": False, "error": "Kh√¥ng t√¨m th·∫•y ƒëo·∫°n chat."})

    for msg in msgs:
        # ‚úÖ Xo√° ·∫£nh th·∫≠t n·∫øu c√≥
        if msg.image_urls:
            for url in msg.image_urls:
                try:
                    # Gi·∫£ s·ª≠ ƒë∆∞·ªùng d·∫´n l√† /static/uploads/abc.jpg
                    image_path = os.path.join(app.root_path, url.strip("/"))  # chuy·ªÉn v·ªÅ ƒë∆∞·ªùng th·∫≠t
                    if os.path.exists(image_path):
                        os.remove(image_path)
                except Exception as e:
                    print("L·ªói khi xo√° ·∫£nh:", e)

        # Xo√° message kh·ªèi database
        db.session.delete(msg)
     
    db.session.commit()
    
    return jsonify({"success": True})


@app.route("/update_privacy", methods=["POST"])
def update_privacy():
    username = session.get("username")
    if not username:
        return jsonify({"success": False, "error": "Ch∆∞a ƒëƒÉng nh·∫≠p."})

    user = User.query.filter_by(username=username).first()
    if not user:
        return jsonify({"success": False, "error": "Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n."})

    data = request.get_json()
    user.privacy = {
        "hide_online": data.get("hide_online", False),
        "hide_avatar": data.get("hide_avatar", False),
        "hide_profile": data.get("hide_profile", False),
        "hide_info": data.get("hide_info", False),
        "hide_all": data.get("hide_all", False),
        "blocked_users": data.get("blocked_users", []),
    }

    db.session.commit()
    return jsonify({"success": True})

@app.route("/get_profile")
def get_profile():
    username = session.get("username")
    if not username:
        return jsonify({})

    user = User.query.filter_by(username=username).first()
    if not user:
        return jsonify({})

    return jsonify({
        "fullname": user.fullname or "",
        "birthday": user.birthday or "",
        "bio": user.bio or "",
        "privacy": user.privacy or {}
    })


@app.route("/update_profile", methods=["POST"])
def update_profile():
    data = request.json
    username = session.get("username")
    if not username:
        return jsonify({"success": False, "message": "Ch∆∞a ƒëƒÉng nh·∫≠p"})

    user = User.query.filter_by(username=username).first()
    if not user:
        return jsonify({"success": False, "message": "Kh√¥ng t√¨m th·∫•y user"})

    user.fullname = data.get("fullname", "")
    user.birthday = data.get("birthday", "")
    user.bio = data.get("bio", "")
    user.bio_updated_at = datetime.utcnow()

    db.session.commit()

    return jsonify({"success": True})

@app.route('/users/search')
def users_search():
    query = request.args.get('q', '').strip().lower()
    current_user = session.get("username", "").lower()

    if not query:
        return jsonify([])

    results = (
        User.query
        .filter(func.lower(User.username) != current_user)
        .filter(
            or_(
                func.lower(User.username).like(f"%{query}%"),
                func.lower(User.fullname).like(f"%{query}%"),
                func.lower(User.user_id).like(f"%{query}%"),
                func.lower(User.phone).like(f"%{query}%")
            )
        )
        .all()
    )

    return jsonify([
        {
            'username': u.username,
            'name': u.fullname,
            'user_id': u.user_id,
            'phone': u.phone,
            'online': u.online,
            'last_seen': u.last_seen.strftime("%Y-%m-%d %H:%M:%S") if u.last_seen else "",
            'avatar_url': u.avatar_url or '/static/logos/logo.png'
        }
        for u in results
    ])
def auto_offline():
    timeout = datetime.datetime.utcnow() - datetime.timedelta(minutes=5)

    users_to_update = User.query.filter(User.last_seen < timeout, User.online == True).all()

    for user in users_to_update:
        user.online = False

    db.session.commit()

@app.before_request
def update_last_seen():
    # ‚ö†Ô∏è CH·∫∂N TRUY C·∫¨P ADMIN n·∫øu kh√¥ng ph·∫£i app ho·∫∑c kh√¥ng ƒë√∫ng email
    if request.path.startswith("/admin"):
        ua = request.headers.get("User-Agent", "")
        allow_email = request.args.get("email", "")
        correct_email = "phatth.viettel@gmail.com"
        if "Electron" not in ua:
            if allow_email != correct_email:
                return "‚õî B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p truy c·∫≠p trang n√†y.", 403

    # üë§ C·∫¨P NH·∫¨T HO·∫†T ƒê·ªòNG NG∆Ø·ªúI D√ôNG
    username = session.get("username")
    if username:
        user = User.query.filter_by(username=username).first()
        if user:
            user.online = True
            user.last_seen = datetime.datetime.utcnow()

            db.session.commit()


@app.route("/friends")
def friends_page():
    current_username = session.get("username")
    if not current_username:
        return redirect("/login")
    
    current_user = User.query.filter_by(username=current_username).first()
    if not current_user:
        return redirect("/login")

    auto_offline()
 
    # ‚úÖ L·∫•y t·∫•t c·∫£ quan h·ªá c√≥ li√™n quan t·ªõi current_user
    friend_links = Friend.query.filter(
        (Friend.user_id == current_user.user_id) | (Friend.friend_id == current_user.user_id)
    ).all()

    friend_list = []
    seen = set()  # ƒê·ªÉ tr√°nh b·ªã tr√πng b·∫°n b√®

    for link in friend_links:
        friend_id = link.friend_id if link.user_id == current_user.user_id else link.user_id
        friend = User.query.filter_by(user_id=friend_id).first()

        if not friend or friend.username in seen:
            continue
        seen.add(friend.username)

        display_name = friend.fullname or friend.username
        print("[CHECK] User:", friend.username, "| Fullname:", friend.fullname)

        online, status_text = get_status(friend.last_seen)
        friend_list.append({
            "username": friend.username,
            "name": friend.fullname,
            "display_name": display_name,
            "fullname": friend.fullname,
            "avatar_url": friend.avatar_url or "/static/logos/logo.png",
            "last_message": "...",
            "online": online,
            "friend_status": status_text
        })
    
    # Th√¥ng tin ng∆∞·ªùi d√πng hi·ªán t·∫°i
    display_name = current_user.fullname or current_user.username
    user_avatar = current_user.avatar_url or url_for('static', filename='logos/logo.png')
    is_online = current_user.online
    user_id = current_user.user_id
    bio = current_user.bio or ""

    show_bio = False
    if bio and current_user.bio_updated_at:
        try:
            if datetime.utcnow() - current_user.bio_updated_at < timedelta(hours=24):
                show_bio = True
        except:
            pass
    print("üîç Current username:", current_username)
    print("üîç Current user_id:", current_user.user_id)
    pending_invites = FriendRequest.query.filter_by(to_user_id=current_user.user_id).count()

    return render_template("friends.html",
        friends=friend_list,
        username=current_username,
        fullname=display_name,
        user_avatar=user_avatar,
        is_online=is_online,
        bio=bio if show_bio else "",
        current_user=current_user,
        user_id=user_id,
        pending_invites=pending_invites  
    )


def load_messages():
    messages_by_chat = {}

    all_msgs = Message.query.order_by(Message.timestamp).all()
    for msg in all_msgs:
        if msg.chat_key not in messages_by_chat:
            messages_by_chat[msg.chat_key] = []

        # L·ªçc ·∫£nh m·∫•t
        valid_images = [
            img for img in msg.image_urls or []
            if os.path.exists("." + img)
        ]

        messages_by_chat[msg.chat_key].append({
            "sender": msg.sender,
            "content": msg.content,
            "image_urls": valid_images,
            "timestamp": msg.timestamp.strftime("%Y-%m-%d %H:%M:%S")
        })

    return messages_by_chat

def save_messages(data):
    Message.query.delete()

    for chat_key, msgs in data.items():
        for m in msgs:
            sender = m.get("sender", "")
            u1, u2  = chat_key.split("__")
            receiver = u2 if u1 == sender else u1

            # json l∆∞u timestamp d·∫°ng ‚Äú2024-06-19 17:45:00‚Äù ‚Äì m·∫∑c ƒë·ªãnh coi l√† VN
            vn_time   = datetime.strptime(m["timestamp"], "%Y-%m-%d %H:%M:%S")
            utc_time  = vn_time.replace(tzinfo=VN_TZ).astimezone(UTC_TZ).replace(tzinfo=None)

            new_msg = Message(
                chat_key = chat_key,
                sender   = sender,
                receiver = receiver,
                content  = m.get("content", ""),
                image_urls = m.get("image_urls", []),
                voice_url  = m.get("voice_url"),            # th√™m n·∫øu c√≥
                timestamp  = utc_time
            )
            db.session.add(new_msg)
    db.session.commit()

def get_status(last_seen):
    if not last_seen:
        return False, "offline"

    now = datetime.utcnow()
    delta = now - last_seen

    if delta < timedelta(minutes=5):
        return True, "ƒêang ho·∫°t ƒë·ªông"
    elif delta < timedelta(hours=1):
        minutes = int(delta.total_seconds() // 60)
        return False, f"ƒê√£ offline {minutes} ph√∫t tr∆∞·ªõc"
    elif delta < timedelta(hours=24):
        hours = int(delta.total_seconds() // 3600)
        return False, f"ƒê√£ offline {hours} gi·ªù tr∆∞·ªõc"
    else:
        return False, "ƒê√£ offline"

@app.route("/chat/send/<username>", methods=["POST"])
def send_message(username):
    current_username = session.get("username")
    if not current_username:
        return jsonify({"error": "Not logged in"}), 403

    sender = User.query.filter_by(username=current_username).first()
    receiver = User.query.filter_by(username=username).first()

    if not sender or not receiver:
        return jsonify({"error": "User not found"}), 404

    # Ki·ªÉm tra b·ªã ch·∫∑n
    if sender in receiver.blocked_users:
        return jsonify({"success": False, "error": "B·∫†N ƒê√É B·ªä CH·∫∂N"})

    # C·∫≠p nh·∫≠t tr·∫°ng th√°i ho·∫°t ƒë·ªông
    sender.last_seen = datetime.utcnow()
    db.session.commit()

    # Nh·∫≠n d·ªØ li·ªáu g·ª≠i
    text = request.form.get("text", "").strip()
    images = request.files.getlist("images")
    voice_file = request.files.get("voice")  # üëà TH√äM voice

    image_urls = []
    voice_url = None

    # ‚úÖ X·ª≠ l√Ω ·∫£nh
    for image in images:
        if image and image.filename:
            ext = image.filename.rsplit(".", 1)[-1].lower()
            if ext in ["png", "jpg", "jpeg", "gif"]:
                filename = f"{uuid.uuid4().hex}.{ext}"
                save_path = os.path.join("static", "images", "uploads", filename)
                os.makedirs(os.path.dirname(save_path), exist_ok=True)

                try:
                    image.save(save_path)
                    start_time = time.time()
                    while not os.path.exists(save_path) or os.path.getsize(save_path) == 0:
                        if time.time() - start_time > 2.0:
                            raise Exception("File save timeout")
                        time.sleep(0.05)
                    image_urls.append(f"/static/images/uploads/{filename}")
                except Exception as e:
                    print("‚ùå L·ªói khi l∆∞u ·∫£nh:", e)

    # ‚úÖ X·ª≠ l√Ω voice
    if voice_file and voice_file.filename:
        ext = voice_file.filename.rsplit(".", 1)[-1].lower()
        if ext in ["mp3", "wav", "m4a", "ogg", "webm"]:
            filename = f"{uuid.uuid4().hex}.{ext}"
            save_path = os.path.join("static", "voices", filename)
            os.makedirs(os.path.dirname(save_path), exist_ok=True)

            try:
                voice_file.save(save_path)
                start_time = time.time()
                while not os.path.exists(save_path) or os.path.getsize(save_path) == 0:
                    if time.time() - start_time > 2.0:
                        raise Exception("Voice save timeout")
                    time.sleep(0.05)
                voice_url = f"/static/voices/{filename}"
            except Exception as e:
                print("‚ùå L·ªói khi l∆∞u voice:", e)

    # N·∫øu kh√¥ng c√≥ g√¨ g·ª≠i th√¨ tr·∫£ l·ªói
    if not text and not image_urls and not voice_url:
        return jsonify({"error": "No content"}), 400

    # T·∫°o chat_key
    chat_key_1 = f"{current_username}__{username}"
    chat_key_2 = f"{username}__{current_username}"
    chat_key = chat_key_1 if current_username < username else chat_key_2

    # ‚úÖ L∆∞u v√†o PostgreSQL
    msg = Message(
        chat_key=chat_key,
        sender=current_username,
        receiver=username,
        content=text if text else None,
        image_urls=image_urls,
        voice_url=voice_url,
        timestamp=datetime.now(VN_TZ),
        read=False
    )
    db.session.add(msg)
    db.session.commit()

    # ‚úÖ Emit ƒë·∫øn ng∆∞·ªùi nh·∫≠n
    socketio.emit("private_message", {
        "from": current_username,
        "to": username,
        "text": msg.content,
        "image_urls": msg.image_urls,
        "voice_url": msg.voice_url,
        "time": msg.timestamp.strftime("%H:%M")
    }, room=f"user_{username}")

    socketio.emit("new_unread_message", {
        "from": current_username
    }, room=f"user_{username}")
    print("‚û°Ô∏è voice_url tr·∫£ v·ªÅ:", voice_url)
    return jsonify({
        "success": True,
        "message": {
            "sender": msg.sender,
            "text": msg.content,
            "image_urls": msg.image_urls,
            "voice_url": msg.voice_url,
            "time": msg.timestamp.strftime("%H:%M"),
            "time_full": msg.timestamp.strftime("%Y-%m-%d %H:%M:%S"),
        }
    })


@app.route("/chat/<username>", methods=["GET"])
def chat(username):
    current_username = session.get("username")
    if not current_username:
        return redirect("/login")

    # Truy v·∫•n ng∆∞·ªùi d√πng t·ª´ PostgreSQL
    current_user = User.query.filter_by(username=current_username).first()
    friend_user = User.query.filter_by(username=username).first()

    if not friend_user:
        return "User not found", 404

    # C·∫≠p nh·∫≠t tr·∫°ng th√°i online v√† last_seen
    current_user.last_seen = datetime.utcnow()
    current_user.online = True
    db.session.commit()

    # Chat key th·ªëng nh·∫•t theo th·ª© t·ª±
    chat_key_1 = f"{current_username}__{username}"
    chat_key_2 = f"{username}__{current_username}"
    chat_key = chat_key_1 if current_username < username else chat_key_2

    # Truy v·∫•n to√†n b·ªô tin nh·∫Øn theo chat_key
    messages = Message.query.filter_by(chat_key=chat_key).order_by(Message.timestamp).all()

    now = datetime.now(UTC_TZ)             # d√πng UTC c√≥ tzinfo

    messages_list = []
    for msg in messages:
        # chuy·ªÉn timestamp t·ª´ DB (gi·∫£ s·ª≠ l∆∞u UTC na√Øve) ‚ûú UTC aware ‚ûú VN
        utc_time = msg.timestamp.replace(tzinfo=UTC_TZ)
        vn_time  = utc_time.astimezone(VN_TZ)

        # c·∫£nh b√°o xo√° 30 ng√†y
        days_since = (now - utc_time).days
        days_left  = 30 - days_since if days_since >= 25 else None

        messages_list.append({
            "sender":     msg.sender,
            "text":       msg.content,
            "image_urls": msg.image_urls or [],
            "voice_url":  msg.voice_url,
            "time":       vn_time.strftime("%H:%M"),
            "time_full":  vn_time.strftime("%Y-%m-%d %H:%M:%S"),
            "days_left":  days_left
        })


    
    friend_name = friend_user.fullname or friend_user.username

    hide_online = friend_user.privacy.get("hide_online", False) if friend_user.privacy else False

    if hide_online:
        online = False
        status_text = ""  # üëà kh√¥ng hi·ªÉn th·ªã g√¨ lu√¥n
    else:
        online, status_text = get_status(friend_user.last_seen)

    return render_template("chat.html",
        username=current_username,
        friend_username=username,
        current_user=current_user,
        friend=friend_user,
        friend_name=friend_name,
        friend_status=status_text,
        messages=messages_list,
        online=online,
        hide_online=hide_online
    )

@app.route("/api/album-images")
def api_album_images():
    current_username = session.get("username")
    friend_username = request.args.get("friend")

    if not current_username or not friend_username:
        return jsonify([])

    messages_data = load_messages()
    chat_key_1 = f"{current_username}__{friend_username}"
    chat_key_2 = f"{friend_username}__{current_username}"
    chat_key = chat_key_1 if chat_key_1 in messages_data else chat_key_2

    chat_history = messages_data.get(chat_key, [])
    image_list = []

    for msg in chat_history:
        for img in msg.get("image_urls", []):
            full_path = os.path.join(".", img.lstrip("/"))
            if os.path.exists(full_path):
                image_list.append({"url": img})

    return jsonify(image_list[::-1])


from datetime import datetime, timedelta

@app.route("/admin/cleanup_chats_30_days")
def cleanup_old_chats():
    env_admin = os.getenv("ADMIN_USERNAME")
    if not (session.get("is_admin") or session.get("username") == env_admin):
        return "Unauthorized", 403

    messages = load_messages()
    removed_chats = []
    removed_images = []

    now = datetime.now()
    cutoff = now - timedelta(days=30)

    for chat_key in list(messages.keys()):
        chat_history = messages[chat_key]
        if not chat_history:
            continue

        # Ki·ªÉm tra n·∫øu t·∫•t c·∫£ tin nh·∫Øn ƒë·ªÅu c≈© h∆°n 30 ng√†y
        all_old = True
        for msg in chat_history:
            try:
                msg_time = datetime.strptime(msg["time_full"], "%Y-%m-%d %H:%M:%S")
                if msg_time > cutoff:
                    all_old = False
                    break
            except:
                all_old = False  # N·∫øu kh√¥ng c√≥ time_full h·ª£p l·ªá th√¨ b·ªè qua xo√°

        if all_old:
            # Xo√° ·∫£nh li√™n quan
            for msg in chat_history:
                for img_url in msg.get("image_urls", []):
                    img_path = os.path.join(".", img_url.lstrip("/"))
                    if os.path.exists(img_path):
                        os.remove(img_path)
                        removed_images.append(img_url)

            # Xo√° ƒëo·∫°n chat
            removed_chats.append(chat_key)  
            del messages[chat_key]

    save_messages(messages)

    return f"‚úÖ ƒê√£ xo√° {len(removed_chats)} ƒëo·∫°n chat & {len(removed_images)} ·∫£nh sau 30 ng√†y."
@app.route("/delete_old_chats")
def delete_old_chats():
    messages_data = load_messages()
    now = datetime.now()
    deleted = 0

    for key in list(messages_data.keys()):
        new_messages = []
        for msg in messages_data[key]:
            time_full = msg.get("time_full")
            if time_full:
                msg_time = datetime.strptime(time_full, "%Y-%m-%d %H:%M:%S")
                if now - msg_time < timedelta(days=30):
                    new_messages.append(msg)
                else:
                    # N·∫øu c√≥ ·∫£nh th√¨ x√≥a ·∫£nh
                    for img in msg.get("image_urls", []):
                        img_path = img.lstrip("/")
                        if os.path.exists(img_path):
                            os.remove(img_path)
                    deleted += 1
            else:
                new_messages.append(msg)  # gi·ªØ l·∫°i tin c≈© kh√¥ng c√≥ time_full
        messages_data[key] = new_messages

    save_messages(messages_data)
    return f"ƒê√£ xo√° {deleted} tin nh·∫Øn c≈© h∆°n 30 ng√†y."
def load_data():
    if not os.path.exists(DATA_FILE):
        return {}
    with open(DATA_FILE, 'r', encoding='utf-8') as f:
        return json.load(f)

def save_data(data):
    with open(DATA_FILE, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def get_username():
    # L·∫•y username hi·ªán t·∫°i, v√≠ d·ª• t·ª´ session
    return session.get('username')

@app.route('/friends/request', methods=['POST'])
def send_friend_request():
    current_username = session.get("username")
    to_username = request.json.get('to_user')

    if not current_username or not to_username:
        return jsonify({'success': False, 'message': 'Thi·∫øu th√¥ng tin'}), 400
    if current_username == to_username:
        return jsonify({'success': False, 'message': 'Kh√¥ng th·ªÉ g·ª≠i l·ªùi m·ªùi cho ch√≠nh m√¨nh'}), 400

    from_user = User.query.filter_by(username=current_username).first()
    to_user = User.query.filter_by(username=to_username).first()

    if not from_user or not to_user:
        return jsonify({'success': False, 'message': 'Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i'}), 404

    # ƒê√£ l√† b·∫°n b√®
    existing = Friend.query.filter_by(user_id=from_user.user_id, friend_id=to_user.user_id).first()
    if existing:
        return jsonify({'success': False, 'message': 'ƒê√£ l√† b·∫°n b√®'}), 400

    # ƒê√£ g·ª≠i l·ªùi m·ªùi
    already_sent = FriendRequest.query.filter_by(from_user_id=from_user.user_id, to_user_id=to_user.user_id).first()
    if already_sent:
        return jsonify({'success': False, 'message': 'ƒê√£ g·ª≠i l·ªùi m·ªùi tr∆∞·ªõc ƒë√≥'}), 400

    fr = FriendRequest(from_user_id=from_user.user_id, to_user_id=to_user.user_id)
    db.session.add(fr)
    db.session.commit()
    return jsonify({'success': True, 'message': 'ƒê√£ g·ª≠i l·ªùi m·ªùi k·∫øt b·∫°n'})


@app.route('/friends/requests', methods=['GET'])
def get_friend_requests():
    current_username = session.get("username")
    current_user = User.query.filter_by(username=current_username).first()

    if not current_user:
        return jsonify([])

    requests = FriendRequest.query.filter_by(to_user_id=current_user.user_id).all()
    results = []
    for r in requests:
        from_user = User.query.filter_by(user_id=r.from_user_id).first()
        if from_user:
            results.append({
                'from_username': from_user.username,
                'from_name': from_user.fullname
            })

    return jsonify(results)

@app.route('/friends/remove', methods=['POST'])
def remove_friend():
    current_username = session.get("username")
    target_username = request.json.get('target_user')

    if not current_username or not target_username:
        return jsonify({'success': False, 'message': 'Thi·∫øu th√¥ng tin'}), 400

    current_user = User.query.filter_by(username=current_username).first()
    target_user = User.query.filter_by(username=target_username).first()

    if not current_user or not target_user:
        return jsonify({'success': False, 'message': 'Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i'}), 404

    # ‚ùå X√≥a c·∫£ 2 chi·ªÅu
    Friend.query.filter_by(user_id=current_user.user_id, friend_id=target_user.user_id).delete()
    Friend.query.filter_by(user_id=target_user.user_id, friend_id=current_user.user_id).delete()

    db.session.commit()

    return jsonify({'success': True, 'message': f'ƒê√£ xo√° b·∫°n v·ªõi {target_username}'})

@app.route('/friends/requests/accept', methods=['POST'])
def accept_friend_request():
    current_username = session.get("username")
    from_username = request.json.get('from_user')

    if not current_username or not from_username:
        return jsonify({'success': False, 'message': 'Thi·∫øu th√¥ng tin'}), 400

    current_user = User.query.filter_by(username=current_username).first()
    from_user = User.query.filter_by(username=from_username).first()

    if not current_user or not from_user:
        return jsonify({'success': False, 'message': 'Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i'}), 404

    already_friends = Friend.query.filter_by(user_id=current_user.user_id, friend_id=from_user.user_id).first()
    if already_friends:
        return jsonify({'success': False, 'message': 'ƒê√£ l√† b·∫°n b√®'}), 400

    # ‚úÖ Th√™m 2 chi·ªÅu
    db.session.add(Friend(user_id=current_user.user_id, friend_id=from_user.user_id))
    db.session.add(Friend(user_id=from_user.user_id, friend_id=current_user.user_id))

    # ‚úÖ Xo√° l·ªùi m·ªùi k·∫øt b·∫°n
    FriendRequest.query.filter_by(from_user_id=from_user.user_id, to_user_id=current_user.user_id).delete()

    db.session.commit()

    return jsonify({'success': True, 'message': 'ƒê√£ ch·∫•p nh·∫≠n l·ªùi m·ªùi', 'from_username': from_username, 'from_name': from_user.fullname})

@app.route('/friends/requests/reject', methods=['POST'])
def reject_friend_request():
    current_username = session.get("username")
    from_username = request.json.get('from_user')

    if not current_username or not from_username:
        return jsonify({'success': False, 'message': 'Thi·∫øu th√¥ng tin'}), 400

    current_user = User.query.filter_by(username=current_username).first()
    from_user = User.query.filter_by(username=from_username).first()

    if not current_user or not from_user:
        return jsonify({'success': False, 'message': 'Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i'}), 404

    req = FriendRequest.query.filter_by(from_user_id=from_user.user_id, to_user_id=current_user.user_id).first()
    if not req:
        return jsonify({'success': False, 'message': 'Kh√¥ng c√≥ l·ªùi m·ªùi t·ª´ ng∆∞·ªùi n√†y'}), 400

    db.session.delete(req)
    db.session.commit()

    return jsonify({'success': True, 'message': 'ƒê√£ t·ª´ ch·ªëi l·ªùi m·ªùi'})


@app.route("/friends/list", methods=["GET"])
def get_friends_list():
    current_username = session.get("username")
    if not current_username:
        return jsonify([])

    current_user = User.query.filter_by(username=current_username).first()
    if not current_user:
        return jsonify([])

    now = datetime.utcnow()
    result = []

    friend_links = Friend.query.filter(
        (Friend.user_id == current_user.user_id) | (Friend.friend_id == current_user.user_id)
    ).all()

    seen = set()

    for link in friend_links:
        friend_id = link.friend_id if link.user_id == current_user.user_id else link.user_id
        friend = User.query.filter_by(user_id=friend_id).first()
        if not friend or friend.username in seen:
            continue
        seen.add(friend.username)

        # ------ tr·∫°ng th√°i online ------
        last_active = friend.last_seen
        is_online = (now - last_active) < timedelta(seconds=60) if last_active else False

        # ------ x√°c ƒë·ªãnh chat_key ------
        chat_key_1 = f"{current_username}__{friend.username}"
        chat_key_2 = f"{friend.username}__{current_username}"
        chat_key = chat_key_1 if current_username < friend.username else chat_key_2

        # ------ ƒê·∫øm tin nh·∫Øn CH∆ØA ƒë·ªçc g·ª≠i t·ªõi current user ------
        unread = Message.query.filter_by(
            chat_key=chat_key,
            receiver=current_username,
            read=False
        ).count()

        # ------ Ki·ªÉm tra tin ch∆∞a ƒë·ªçc m·ªõi nh·∫•t c√≥ ph·∫£i ch·ªâ 1 ·∫£nh ------
        image_only = False
        if unread:
            newest = Message.query.filter_by(
                        chat_key=chat_key,
                        receiver=current_username,
                        read=False
                     ).order_by(Message.timestamp.desc()).first()
            if newest and newest.image_urls and not newest.content:
                image_only = len(newest.image_urls) == 1

        # ------ G·ªôp v√†o k·∫øt qu·∫£ ------
        result.append({
            "username": friend.username,
            "display_name": friend.fullname or friend.username,
            "name": friend.fullname or friend.username,
            "unread": unread,
            "image_only": image_only,
            "is_online": is_online,
            "avatar_url": friend.avatar_url or "/static/logos/logo.png",
            "hide_avatar": friend.privacy.get("hide_avatar") if friend.privacy else False,
            "chat_key": chat_key
        })

    return jsonify(result)
@app.route("/chat/mark_read/<username>", methods=["POST"])
def mark_messages_as_read(username):
    current_username = session.get("username")
    if not current_username:
        return jsonify({"error": "Not logged in"}), 403

    chat_key_1 = f"{current_username}__{username}"
    chat_key_2 = f"{username}__{current_username}"
    chat_key = chat_key_1 if current_username < username else chat_key_2

    # ‚úÖ C·∫≠p nh·∫≠t t·∫•t c·∫£ tin g·ª≠i t·ªõi current_user v√† ch∆∞a ƒë·ªçc
    Message.query.filter_by(chat_key=chat_key, receiver=current_username, read=False).update({"read": True})
    db.session.commit()

    return jsonify({"success": True})

@app.route("/chat/unread_status")
def unread_status():
    username = session.get("username")
    if not username:
        return jsonify({})

    unread = Message.query.filter_by(receiver=username, read=False).all()
    return jsonify({m.sender: True for m in unread})


@app.route("/rename", methods=["POST"])
def rename_friend():
    current_username = session.get("username")
    if not current_username:
        return "Unauthorized", 403
    
    data = request.get_json()
    target = data.get("target_username")
    nickname = data.get("nickname", "").strip()

    user_data = load_data()
    user_data.setdefault(current_username, {}).setdefault("nicknames", {})

    if nickname:
        user_data[current_username]["nicknames"][target] = nickname
    else:
        user_data[current_username]["nicknames"].pop(target, None)

    save_data(user_data)
    return "OK"





@app.route("/upload_image", methods=["POST"])
def upload_image():
      # ‚úÖ N·∫øu ƒë√£ h·∫øt l∆∞·ª£t d√πng th·ª≠ AI To√°n ‚Üí ch·∫∑n l·∫°i
    if session.get("username") != "admin":
        user_type = get_user_type()
        if user_type != "vip":
            if not check_lite_usage():
                return jsonify({
                    "reply": "‚ö†Ô∏è B·∫°n ƒë√£ d√πng h·∫øt 10 l∆∞·ª£t AI mi·ªÖn ph√≠. Vui l√≤ng n√¢ng c·∫•p VIP ƒë·ªÉ ti·∫øp t·ª•c s·ª≠ d·ª•ng."
                })

    image = request.files.get("image")
    if image:
        filename = secure_filename(image.filename)
        save_path = os.path.join("static", "images", "uploads", filename)
        image.save(save_path)

        try:
            solution_raw = extract_with_gpt_vision(save_path)
            session["last_ai_math_answer"] = solution_raw
            return jsonify({"reply": str (solution_raw)})
        except Exception as e:
            print("L·ªói GPT Vision:", e)
            return jsonify({"reply": "‚ö†Ô∏è ·∫¢nh c√≥ v√†i chi ti·∫øt h∆°i m·ªù,Anh/Ch·ªã c√≥ th·ªÉ ch·ª•p l·∫°i r√µ h∆°n r·ªìi g·ª≠i l·∫°i gi√∫p em nh√©."})
    else:
        return jsonify({"reply": "‚ùå Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ·∫£nh n√†o."})




@app.route("/upload_pdf", methods=["POST"])
def upload_pdf():
    file = request.files.get("pdf")
    if not file:
        return jsonify({"reply": "‚ùå Kh√¥ng nh·∫≠n ƒë∆∞·ª£c file PDF."})

    pdf_text = ""
    try:
        with fitz.open(stream=file.read(), filetype="pdf") as doc:
            for page in doc:
                pdf_text += page.get_text()

        print("[DEBUG] PDF TEXT:", pdf_text)

        # G·ªçi AI gi·∫£i b√†i lu√¥n t·ª´ n·ªôi dung PDF
        reply = call_gpt_viet(pdf_text)

        reply = "‚úèÔ∏è R·ªìi nha, em b·∫Øt ƒë·∫ßu gi·∫£i t·ª´ng c√¢u cho anh/ch·ªã n√®!\n\n" + reply
        reply += "\n\nüí¨ N·∫øu c·∫ßn em gi·∫£i ti·∫øp b√†i kh√°c th√¨ c·ª© g·ª≠i th√™m ·∫£nh ho·∫∑c g√µ ti·∫øp nh√©!"
        return jsonify({"reply": reply})
    except Exception as e:
        print("‚ùå L·ªói khi x·ª≠ l√Ω PDF:", e)
        return jsonify({"reply": "‚ö†Ô∏è Kh√¥ng th·ªÉ x·ª≠ l√Ω file PDF. Vui l√≤ng th·ª≠ l·∫°i v·ªõi file kh√°c."})
#==========GPT==========#
@app.route("/gpt_chat", methods=["GET"])
def gpt_chat():
    if is_maintenance("gpt_chat"):
        return render_template("gpt_chat.html",
            user_id=None,
            username=None,
            user_vip_gpt=False,
            user_vip_al=False,
            user_lite_exhausted=False,
            is_vip_chat=False,
            is_verified=False,
            chat_history=[],
            chat_id=None,
            chat_title="",
            is_maintenance=True
        )

    cleanup_old_chats()

    username = session.get("username")
    if not username:
        return redirect("/login")

    user = User.query.filter_by(username=username).first()
    if not user:
        return redirect("/login")

    if user.is_blocked:
        session.clear()
        return render_template("login.html", error="üö´ T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã kho√°. Vui l√≤ng li√™n h·ªá admin.")
    
    now = datetime.utcnow()

    # ‚úÖ ∆Øu ti√™n g√≥i GPT n·∫øu c√≤n h·∫°n
    is_vip = False
    if username == "admin":
        is_vip = True
    elif user.vip_until_gpt and user.vip_until_gpt >= now:
        is_vip = True

    # ‚ùó N·∫øu kh√¥ng c√≥ g√≥i GPT ‚Üí ki·ªÉm tra AI Lite
    if not is_vip and user.vip_until_lite and user.vip_until_lite >= now:
        return redirect("/chat_lite")


    # ‚úÖ Ch·∫∑n n·∫øu l√† g√≥i 5 ng√†y v√† ƒë√£ h·∫øt 100 l∆∞·ª£t (tr·ª´ khi gpt_unlimited)
    if is_vip and user.vip_gpt == "5day" and not user.gpt_unlimited:
        usage_today = user.gpt_usage_today or 0
        usage_date = user.gpt_usage_date or ""
        today = now.strftime("%Y-%m-%d")

        if usage_date != today:
            usage_today = 0  # reset l·∫°i

        if usage_today >= 100:
            return render_template("gpt_chat.html",
                user_id=user.id,
                username=user.username,
                user_vip_gpt=True,
                user_vip_al=True,
                user_lite_exhausted=False,
                is_vip_chat=False,
                is_verified=user.is_verified,
                message_from_home="üö´ B·∫°n ƒë√£ d√πng h·∫øt 100 l∆∞·ª£t GPT h√¥m nay. Vui l√≤ng quay l·∫°i v√†o ng√†y mai ho·∫∑c n√¢ng c·∫•p g√≥i.",
                chat_history=[],
                chat_id=None,
                chat_title=""
            )

    # ‚úÖ Ki·ªÉm tra x√°c th·ª±c v√† gi·ªõi h·∫°n Lite
    lite_used = user.lite_usage or 0
    is_verified = user.is_verified

    lite_exhausted = not is_verified and lite_used >= 5

    # üóÇ Chat history
    chat_history = []
    chat_file = os.path.join("chat_history", f"{user.id}.json")
    if os.path.exists(chat_file):
        try:
            with open(chat_file, "r", encoding="utf-8") as f:
                chat_history = json.load(f)
        except Exception as e:
            print("[üí•] L·ªói khi ƒë·ªçc ƒëo·∫°n chat m·∫∑c ƒë·ªãnh:", e)

    session.pop("just_verified_already", None)

    return render_template("gpt_chat.html",
        user_id=user.id,
        username=user.username,
        user_vip_gpt=is_vip,
        user_vip_al=is_vip,
        user_lite_exhausted=lite_exhausted,
        is_vip_chat=is_vip,
        is_verified=is_verified,
        message_from_home=None,
        chat_history=chat_history,
        chat_id=None,
        chat_title="",
        is_maintenance=False
    )

@app.route("/gpt_viet_chat", methods=["POST"])
def gpt_viet_chat():
    if "username" not in session:
        return jsonify({"success": False, "reply": "üîí B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p."})

    username = session["username"]
    user_id = session.get("user_id", "guest")

    user = User.query.filter_by(username=username).first()
    if not user:
        return jsonify({"success": False, "reply": "‚ùå Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng."})
    if not check_gpt_usage(user):
        return jsonify({"success": False, "reply": "üö´ B·∫°n ƒë√£ d√πng h·∫øt l∆∞·ª£t Solver trong ng√†y ho·∫∑c g√≥i ƒë√£ h·∫øt h·∫°n."})

    cap_nhat_trang_thai_vip(user)
    db.session.commit()

    if username != "admin" and not user.vip_gpt_ai:
        return jsonify({"success": False, "reply": "üîí B·∫°n ch∆∞a m·ªü kh√≥a g√≥i Solver Chat."})

    message = request.form.get("message", "").strip()
    img_url = None

    try:
        history = json.loads(request.form.get("history", "[]"))

        # ‚úÖ X·ª≠ l√Ω ·∫£nh t·∫°o b·∫±ng GPT
        if re.search(r"\b(v·∫Ω|cho.*(·∫£nh|tranh|h√¨nh|minh ho·∫°)|t·∫°o.*c·∫£nh|minh ho·∫°)\b", message, re.IGNORECASE):
            image_prompt = rewrite_prompt_for_image(message)
            if not image_prompt:
                return jsonify({"success": False, "reply": "‚ùå Kh√¥ng th·ªÉ t·∫°o ·∫£nh t·ª´ y√™u c·∫ßu n√†y."})

            img_url = generate_image_from_prompt(image_prompt)
            if not img_url:
                return jsonify({"success": False, "reply": "‚ö†Ô∏è Kh√¥ng t·∫°o ƒë∆∞·ª£c ·∫£nh, th·ª≠ l·∫°i sau nha!"})

            reply_text = random.choice([
                "üé® ƒê√¢y l√† ·∫£nh em t·∫°o theo tr√≠ t∆∞·ªüng t∆∞·ª£ng c·ªßa b·∫°n n√®!",
                "üñåÔ∏è ·∫¢nh minh ho·∫° ƒë√£ xong, b·∫°n xem th·ª≠ nha!",
                "‚ú® ·∫¢nh n√®! Hy v·ªçng ƒë√∫ng vibe b·∫°n mu·ªën üòÑ"
            ]) + f"<br><img src='{img_url}' style='max-width:100%; border-radius:12px; margin-top:10px;'>"

            history.append({"role": "user", "content": message})
            history.append({"role": "assistant", "content": reply_text})
            save_chat(user_id, history)

            return jsonify({"success": True, "reply": reply_text, "img_url": img_url})
    except Exception as e:
        print("‚ùå GPT IMAGE ERROR:", e)
        history = []

    try:
        # ‚úÖ X·ª≠ l√Ω ·∫£nh upload (Vision)
        vision_texts = []
        vision_image_url = None
        for key in request.files:
            file = request.files[key]
            if file.filename:
                ext = os.path.splitext(file.filename)[-1]
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = secure_filename(f"{timestamp}_{username}_{key}{ext}")
                user_folder = os.path.join('static', 'images', 'uploads', str(user_id))
                os.makedirs(user_folder, exist_ok=True)
                save_path = os.path.join(user_folder, filename)
                file.save(save_path)

                vision_output = extract_with_gpt_vision(save_path, user_request=message)
                vision_texts.append(f"[·∫¢nh: {filename}]\n{vision_output}")
                vision_image_url = f"/static/images/uploads/{user_id}/{filename}"

        if vision_texts:
            vision_combined = "\n\n".join(vision_texts)
            if message:
                message += f"\n\nüñº D∆∞·ªõi ƒë√¢y l√† n·ªôi dung AI tr√≠ch t·ª´ ·∫£nh:\n{vision_combined}"
            else:
                message = f"üñº AI ƒë√£ tr√≠ch n·ªôi dung t·ª´ ·∫£nh nh∆∞ sau:\n{vision_combined}"

       
        reply = call_gpt_viet(message, history)

        if vision_image_url:
            reply += f"<br><img src='{vision_image_url}' style='max-width:300px; border-radius:12px; margin-top:10px;'>"

        history.append({"role": "user", "content": message})
        history.append({"role": "assistant", "content": reply})
        save_chat(user_id, history)

        return jsonify({
            "success": True,
            "reply": reply,
            "img_url": vision_image_url or img_url
        })

    except Exception as e:
        print("‚ùå GPT CHAT ERROR:", e)
        return jsonify({
            "reply": "‚ö†Ô∏è H·ªá th·ªëng qu√° t·∫£i, b·∫°n h√£y th·ª≠ l·∫°i trong √≠t ph√∫t n·ªØa ho·∫∑c t·∫°o ƒëo·∫°n chat m·ªõi."
        })


@app.route("/smart_emoji", methods=["POST"])
def smart_emoji():
    data = request.get_json()
    message = data.get("message", "").strip()

    # ‚úÖ Kh√¥ng ki·ªÉm tra g√≥i, ch·ªâ c·∫ßn user ƒëƒÉng nh·∫≠p l√† ƒë·ªß
    user_id = session.get("user_id")
    if not user_id:
        return jsonify({"emoji": []})

    # ‚úÖ Prompt AI g·ª£i √Ω emoji theo ng·ªØ c·∫£nh
    prompt = f"""
Ng∆∞·ªùi d√πng ƒëang g√µ c√¢u: \"{message}\". ƒêo√°n nhanh c·∫£m x√∫c ho·∫∑c ch·ªß ƒë·ªÅ (vui, bu·ªìn, h·ªçc t·∫≠p, troll, t√¨nh c·∫£m, gi·∫≠n d·ªói...). 
D·ª±a v√†o ƒë√≥, g·ª£i √Ω 3‚Äì4 emoji ph√π h·ª£p. Ch·ªâ tr·∫£ v·ªÅ m·∫£ng JSON, v√≠ d·ª•: ["üòÇ", "üìö", "üò¢", "ü•∞"].
Kh√¥ng th√™m ch·ªØ, kh√¥ng gi·∫£i th√≠ch.
"""

    try:
        client = create_openai_client()
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.5,
            max_tokens=50
        )

        text = response.choices[0].message.content.strip()
        print("üîé GPT Emoji raw reply:", text)

        if text.startswith("[") and text.endswith("]"):
            emoji_list = eval(text)
            if isinstance(emoji_list, list):
                return jsonify({"emoji": emoji_list})

        return jsonify({"emoji": []})  # Tr·∫£ v·ªÅ r·ªóng n·∫øu sai ƒë·ªãnh d·∫°ng

    except Exception as e:
        print("‚ùå L·ªói smart emoji:", e)
        return jsonify({"emoji": []})



@app.route("/chat_ai_lite", methods=["POST"])
def chat_ai_lite():
    if is_maintenance("chat_ai_lite_daily") or is_maintenance("all"):
        return jsonify({"reply": "üöß H·ªá th·ªëng ƒëang b·∫£o tr√¨. Vui l√≤ng quay l·∫°i sau!"}), 503

    username = session.get("username")
    user = User.query.filter_by(username=username).first() if username else None
    if not user:
        return jsonify({"reply": "‚ùå Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng."}), 404

    # N·∫øu c√≥ g√≥i Lite v√† ƒëang b·∫£o tr√¨ ri√™ng Lite
    now = now_vn()
    try:
        if user.vip_until_lite and now <= datetime.strptime(user.vip_until_lite, "%Y-%m-%d %H:%M:%S"):
            if is_maintenance("chat_lite"):
                return jsonify({"reply": "üöß G√≥i AI Lite ƒëang b·∫£o tr√¨. Vui l√≤ng quay l·∫°i sau!"}), 503
        elif user.is_verified and is_maintenance("chat_ai_lite"):
            return jsonify({"reply": "üöß AI Free 15 l∆∞·ª£t ƒëang b·∫£o tr√¨. Vui l√≤ng quay l·∫°i sau!"}), 503
    except:
        pass

    usage_check = check_lite_usage(user)

    if usage_check == "require_verification":
        return jsonify({"reply": "üì© B·∫°n ƒë√£ d√πng h·∫øt 5 l∆∞·ª£t mi·ªÖn ph√≠. <a href='/verify-otp' style='color:#00e676;font-weight:bold;'>X√°c th·ª±c t√†i kho·∫£n ngay</a> ƒë·ªÉ nh·∫≠n th√™m 10 l∆∞·ª£t n·ªØa!"})

    elif usage_check is False:
        if user.is_blocked:
            return jsonify({"reply": "üö´ T√†i kho·∫£n b·∫°n ƒë√£ b·ªã ch·∫∑n kh√¥ng cho chat. Vui l√≤ng li√™n h·ªá admin ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt."})

        try:
            if user.vip_until_lite and now <= datetime.strptime(user.vip_until_lite, "%Y-%m-%d %H:%M:%S"):
                return jsonify({"reply": "üîí B·∫°n ƒë√£ d√πng h·∫øt 50 l∆∞·ª£t h√¥m nay c·ªßa g√≥i AI Lite. Vui l√≤ng quay l·∫°i v√†o ng√†y mai!"})
        except:
            pass

        if user.is_verified:
            return jsonify({"reply": "üîí B·∫°n ƒë√£ d√πng h·∫øt 5 l∆∞·ª£t mi·ªÖn ph√≠ trong ng√†y h√¥m nay. Vui l√≤ng quay l·∫°i v√†o ng√†y mai ho·∫∑c n√¢ng c·∫•p AI Lite/Solver ƒë·ªÉ ti·∫øp t·ª•c s·ª≠ d·ª•ng."})
        else:
            return jsonify({"reply": "üîí B·∫°n ƒë√£ d√πng h·∫øt 5 l∆∞·ª£t mi·ªÖn ph√≠. Vui l√≤ng x√°c th·ª±c t√†i kho·∫£n ƒë·ªÉ nh·∫≠n th√™m 10 l∆∞·ª£t n·ªØa!"})
    # --- x·ª≠ l√Ω message ---
    message = request.form.get("message", "").strip()
    if not message:
        return jsonify({"reply": "‚ö†Ô∏è B·∫°n ch∆∞a nh·∫≠p n·ªôi dung c√¢u h·ªèi."})

    history_str = request.form.get("history", "[]")
    try:
        history = json.loads(history_str)
    except Exception as e:
        print("[üí•] Kh√¥ng parse ƒë∆∞·ª£c history:", e)
        history = []

    # ‚úÖ N·∫øu l√† y√™u c·∫ßu t·∫°o ·∫£nh th√¨ tr·∫£ l·ªùi t·ª´ ch·ªëi ngay (ƒë·∫∑t TR∆Ø·ªöC G·ªåI GPT)
    if re.search(r"\b(v·∫Ω|minh ho·∫°|h√¨nh ·∫£nh|·∫£nh|tranh)\b", message, re.IGNORECASE):
        reply = "üñºÔ∏è R·∫•t ti·∫øc, b·∫£n mi·ªÖn ph√≠ v√† g√≥i Lite ch∆∞a h·ªó tr·ª£ t·∫°o ·∫£nh. B·∫°n h√£y n√¢ng c·∫•p g√≥i SolverSolver ƒë·ªÉ d√πng t√≠nh nƒÉng n√†y nh√©!"

        history.append({"role": "user", "content": message})
        history.append({"role": "assistant", "content": reply})

        user_id = session.get("user_id")
        if user_id:
            save_chat(user_id, history)

        return jsonify({"reply": reply})
    # --- x·ª≠ l√Ω ·∫£nh ---
    images = []
    vision_texts = []
    image_tags = []
    for key in request.files:
        file = request.files[key]
        if file.filename:
            ext = os.path.splitext(file.filename)[-1]
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = secure_filename(f"{timestamp}_guest_{key}{ext}")
            save_path = os.path.join('static/images/uploads', filename)
            file.save(save_path)
            image_url = f"/static/images/uploads/{filename}"
            image_tags.append(f"<img src='{image_url}' style='max-width:200px; border-radius:8px; margin-top:8px;'>")
            vision_output = extract_with_gpt_vision(save_path, user_request=message)
            vision_texts.append(f"[·∫¢nh: {filename}]\n{vision_output}")

    if vision_texts:
        if image_tags:
            message += "<br>" + "<br>".join(image_tags)
        vision_combined = "\n\n".join(vision_texts)
        message += f"\n\nüñº D∆∞·ªõi ƒë√¢y l√† n·ªôi dung AI tr√≠ch t·ª´ ·∫£nh:\n{vision_combined}"

    try:
        reply = call_gpt_lite(message, history)
    except Exception as e:
        print("‚ùå L·ªói khi g·ªçi GPT Lite:", e)
        return jsonify({"reply": "‚ö†Ô∏è H·ªá th·ªëng qu√° t·∫£i, b·∫°n h√£y th·ª≠ l·∫°i trong √≠t ph√∫t n·ªØa ho·∫∑c t·∫°o ƒëo·∫°n chat m·ªõi."})

    if vision_texts:
        reply += "\n\nC√≥ th·ªÉ m·ªôt v√†i chi ti·∫øt trong ·∫£nh h∆°i m·ªù nh·∫°t ho·∫∑c sai. Mong b·∫°n ki·ªÉm tra l·∫°i gi√∫p m√¨nh nha."

    history.append({"role": "user", "content": message})
    history.append({"role": "assistant", "content": reply})

    user_id = session.get("user_id")
    if user_id:
        save_chat(user_id, history)

    # --- tr·ª´ l∆∞·ª£t n·∫øu ch∆∞a x√°c th·ª±c ---
    if not user.is_verified:
        user.free_gpt_uses = max(0, (user.free_gpt_uses or 0) - 1)
        db.session.commit()

    return jsonify({"reply": reply})


#AI LITE
@app.route("/chat_lite", methods=["GET"])
def chat_lite():
    if is_maintenance("chat_lite"):
        return render_template("maintenance.html")

    username = session.get("username")
    user_id = session.get("user_id")

    if not username or not user_id:
        return redirect("/login")

    user = User.query.filter_by(username=username).first()
    if not user:
        return redirect("/login")

    # üõ°Ô∏è N·∫øu ch∆∞a x√°c th·ª±c v√† ƒë√£ h·∫øt l∆∞·ª£t mi·ªÖn ph√≠ ‚Üí b·∫Øt x√°c th·ª±c
    if not user.is_verified and (user.free_gpt_uses or 0) <= 0:
        return redirect("/verify-otp")

    # ‚ùå N·∫øu c√≥ g√≥i GPT ‚Üí redirect
    now = now_vn()
    def valid(s):
        try:
            return datetime.strptime(s, "%Y-%m-%d %H:%M:%S") > now
        except:
            return False

    if user.vip_gpt_ai and valid(user.vip_until_gpt or ""):
        return redirect("/chat_redirect")

    # üóÇ L·ªãch s·ª≠ ƒëo·∫°n chat (v·∫´n l·∫•y t·ª´ file)
    chat_history = []
    chat_file = os.path.join("chat_history", f"{user_id}.json")
    if os.path.exists(chat_file):
        try:
            with open(chat_file, "r", encoding="utf-8") as f:
                chat_history = json.load(f)
        except Exception as e:
            print(f"[üí•] Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c chat_history: {e}")

    return render_template(
        "chat_ai_lite.html",
        user_id=user_id,
        username=username,
        user_lite_exhausted=False,
        is_verified=user.is_verified,
        chat_history=chat_history,
        chat_id=None,
        chat_title="",
        is_maintenance=is_maintenance("chat_lite")
    )

#RESET LU·ª¢T M·ªñI NG√ÄY
@app.route("/chat_ai_lite", methods=["GET"])
def chat_ai_lite_page():
    if is_maintenance("chat_ai_lite_daily"):
        return render_template("maintenance.html")

    username = session.get("username")
    user_id = session.get("user_id")

    if not username or not user_id:
        return redirect("/login")

    user = User.query.filter_by(username=username).first()
    if not user:
        return redirect("/login")

    # üõ°Ô∏è N·∫øu ch∆∞a x√°c th·ª±c v√† ƒë√£ h·∫øt l∆∞·ª£t mi·ªÖn ph√≠ ‚Üí b·∫Øt x√°c th·ª±c
    if not user.is_verified and (user.free_gpt_uses or 0) <= 0:
        return redirect("/verify-otp")

    # ‚ùå N·∫øu c√≥ g√≥i GPT ho·∫∑c AI Lite ‚Üí redirect
    now = now_vn()
    def valid(date_str):
        for fmt in ("%Y-%m-%d %H:%M:%S", "%Y-%m-%d"):
            try:
                return datetime.strptime(date_str, fmt) > now
            except:
                continue
        return False
    if (user.vip_gpt_ai and valid(user.vip_until_gpt or "")) or \
       (user.vip_ai_lite and valid(user.vip_until_lite or "")):
        return redirect("/chat_redirect")

    # üóÇ L·ªãch s·ª≠ ƒëo·∫°n chat
    chat_history = []
    chat_file = os.path.join("chat_history", f"{user_id}.json")
    if os.path.exists(chat_file):
        try:
            with open(chat_file, "r", encoding="utf-8") as f:
                chat_history = json.load(f)
        except Exception as e:
            print(f"[üí•] Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c chat_history: {e}")

    return render_template(
        "chat_ai_lite_daily.html",
        user_id=user_id,
        username=username,
        user_lite_exhausted=False,
        is_verified=user.       verified,
        chat_history=chat_history,
        chat_id=None,
        chat_title="",
        is_maintenance=is_maintenance("chat_ai_lite")
    )


# KI·ªÇM TRA G√ìI CHAT
@app.route("/chat_redirect", methods=["GET"])
def chat_redirect():
    if is_maintenance("chat_ai_lite_daily") or \
       is_maintenance("chat_ai_lite") or \
       is_maintenance("chat_lite") or \
       is_maintenance("gpt_chat"):
        return render_template("maintenance.html")

    username = session.get("username")
    if not username:
        return redirect("/login")

    user = User.query.filter_by(username=username).first()
    if not user:
        return redirect("/login")

    now = now_vn()

    def valid(dt):
        try:
            if isinstance(dt, str):
                dt = datetime.strptime(dt, "%Y-%m-%d %H:%M:%S")
            return dt > now
        except:
            return False

    # G√≥i GPT c√≤n h·∫°n
    if user.vip_gpt and valid(user.vip_until_gpt):
        return redirect("/gpt_chat")  # gpt_chat.html

    # G√≥i AI Lite c√≤n h·∫°n
    if user.vip_ai_lite and valid(user.vip_until_lite):
        return redirect("/chat_lite")  # chat_ai_lite.html

    # T√†i kho·∫£n m·ªõi t·∫°o (15 l∆∞·ª£t free)
    if (user.free_gpt_uses or 0) > 0:
        return render_template("gpt_chat_lite.html", chat_history=[])

    # ƒê√£ x√°c th·ª±c ‚Üí Free 5 l∆∞·ª£t m·ªói ng√†y
    if user.is_verified:
        return render_template("chat_ai_lite_daily.html", chat_history=[])

    # Ch∆∞a x√°c th·ª±c, h·∫øt free ‚Üí B·∫Øt x√°c th·ª±c
    flash("üì© B·∫°n c·∫ßn x√°c th·ª±c email ƒë·ªÉ ti·∫øp t·ª•c s·ª≠ d·ª•ng AI.")
    return redirect("/verify-otp")


#G·ª¨I TIN T·ª™ HOME QUA AI V√Ä T·ª∞ KI·ªÇM TRA TH√îNG MINH
@app.route("/get-user-package")
def get_user_package():
    from datetime import datetime
    username = session.get("username")
    if not username:
        return jsonify({"status": "not_logged_in"})

    user = User.query.filter_by(username=username).first()
    if not user:
        return jsonify({"status": "not_logged_in"})

    now = now_vn()

    # Ki·ªÉm tra VIP GPT
    is_vip_gpt = False
    if user.vip_gpt:
        try:
            vip_until = datetime.strptime(user.vip_until_gpt, "%Y-%m-%d %H:%M:%S")
            is_vip_gpt = now <= vip_until
        except:
            pass

    # Ki·ªÉm tra g√≥i AI Lite
    is_lite = False
    if user.vip_ai_lite:
        try:
            lite_until = datetime.strptime(user.vip_until_lite, "%Y-%m-%d %H:%M:%S")
            is_lite = now <= lite_until
        except:
            pass

    return jsonify({
        "status": "ok",
        "is_vip_gpt": is_vip_gpt,
        "is_lite": is_lite,
        "verified": user.is_verified
    })


#AI V·∫º H√åNH
def generate_ai_prompt(user_text):
    return (
        f"T·∫°o h√¨nh ·∫£nh theo m√¥ t·∫£: {user_text}. "
        "·∫¢nh n√™n r√µ r√†ng, tr√¨nh b√†y ƒë·∫πp, kh√¥ng th√™m chi ti·∫øt d∆∞ th·ª´a, ph√π h·ª£p s√°ch v·ªü ho·∫∑c minh ho·∫° h·ªçc thu·∫≠t."
    )
@app.route("/generate_image_from_text", methods=["POST"])
def draw_math_figure():
    data = request.json
    user_input = data.get("text", "")

    if not user_input:
        return jsonify({"error": "B·∫°n ch∆∞a nh·∫≠p n·ªôi dung c·∫ßn v·∫Ω."})

    try:
        prompt = generate_ai_prompt(user_input)
        image_url = generate_image_from_prompt(prompt)
        return jsonify({"img_url": image_url, "source": "ai"})
    except Exception as e:
        print("‚ùå L·ªói t·∫°o h√¨nh AI:", e)
        return jsonify({"error": "Kh√¥ng t·∫°o ƒë∆∞·ª£c h√¨nh t·ª´ AI. Vui l√≤ng th·ª≠ l·∫°i."})



@app.route("/generate_image", methods=["POST"])
def generate_image():
    username = session.get("username")
    if not username:
        return jsonify({"error": "üîí B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p."})

    user = User.query.filter_by(username=username).first()
    if not user:
        return jsonify({"error": "üîí Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n."})

    cap_nhat_trang_thai_vip(user)
    db.session.commit()

    # ‚úÖ Admin ƒë∆∞·ª£c ph√©p t·∫°o ·∫£nh kh√¥ng gi·ªõi h·∫°n
    if username != "admin":
        if not user.vip_gpt_ai and user.lite_usage >= 20:
            return jsonify({"error": "‚ö†Ô∏è B·∫°n ƒë√£ h·∫øt l∆∞·ª£t mi·ªÖn ph√≠ ho·∫∑c g√≥i AI ƒë√£ h·∫øt h·∫°n."})

    prompt = request.json.get("prompt", "").strip()
    if not prompt:
        return jsonify({"error": "‚ùå B·∫°n ch∆∞a nh·∫≠p n·ªôi dung h√¨nh mu·ªën t·∫°o."})

    try:
        img_url = generate_image_from_prompt(prompt)
        return jsonify({"img_url": img_url})
    except Exception as e:
        print("‚ùå L·ªói khi t·∫°o ·∫£nh:", e)
        return jsonify({"error": "‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫°o ·∫£nh. Vui l√≤ng th·ª≠ l·∫°i sau."})

#G·ª¨I FILE
@app.route("/upload_file", methods=["POST"])
def upload_file():
    if "file" not in request.files:
        return jsonify({"reply": "Kh√¥ng c√≥ file ƒë∆∞·ª£c g·ª≠i."}), 400

    file = request.files["file"]
    if file.filename == "":
        return jsonify({"reply": "File kh√¥ng h·ª£p l·ªá."}), 400

    filename = secure_filename(file.filename)
    user_id = session.get("user_id", "guest")
    existing_path = os.path.join("static", "images", "uploads", user_id, filename)

    if not os.path.exists(existing_path):
        print("‚ö†Ô∏è [UPLOAD] File kh√¥ng t·ªìn t·∫°i trong th∆∞ m·ª•c ng∆∞·ªùi d√πng:", existing_path)
        return jsonify({"reply": "‚ö†Ô∏è File kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã xo√°."}), 400

    # ‚úÖ C·∫≠p nh·∫≠t th·ªùi gian s·ª≠a file ƒë·ªÉ l·ªçc 7 ng√†y
    os.utime(existing_path, None)
    print("üì• [UPLOAD] ƒê√£ c·∫≠p nh·∫≠t mtime cho:", existing_path)

    return jsonify({"reply": f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t ·∫£nh: {filename}"})



#M·ªû √ÇM BUM
@app.route("/get_user_album")
def get_user_album():
    user_id = session.get("user_id", "guest")
    upload_dir = os.path.join("static", "images", "uploads", str(user_id))

    now = time.time()
    max_age = 7 * 86400  # 7 ng√†y

    print(f"[ALBUM] ƒêang ki·ªÉm tra ·∫£nh t·∫°i: {upload_dir}")

    images = []
    if os.path.exists(upload_dir):
        for filename in os.listdir(upload_dir):
            if filename.lower().endswith((".png", ".jpg", ".jpeg", ".gif", ".webp")):
                path = os.path.join(upload_dir, filename)
                mtime = os.path.getmtime(path)
                age = now - mtime

                print(f"[ALBUM] ·∫¢nh: {filename}, mtime: {mtime}, age: {age}")

                if age <= max_age:
                    images.append({
                        "path": f"/{path.replace(os.sep, '/')}"
                    })
    print(f"üì∏ [ALBUM] ƒê√£ t√¨m th·∫•y {len(images)} ·∫£nh g·∫ßn nh·∫•t trong {upload_dir}")
    print(f"[ALBUM] T·ªïng c·ªông {len(images)} ·∫£nh h·ª£p l·ªá.")
    return jsonify({"images": images})
#L·ªäCH S·ª¨ ƒêO·∫†N CHAT
@app.route("/save_chat", methods=["POST"])
def save_chat_route():
    user_id = session.get("user_id")
    if not user_id:
        return jsonify({"error": "Not logged in"}), 401

    data = request.get_json()
    messages = data.get("messages", [])

    folder = os.path.join("chat_history")
    os.makedirs(folder, exist_ok=True)

    file_path = os.path.join(folder, f"{user_id}.json")

    try:
        with open(file_path, "w", encoding="utf-8") as f:
            json.dump(messages, f, ensure_ascii=False, indent=2)
        return jsonify({"status": "saved"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route("/load_chat/<chat_id>")
def load_chat(chat_id):
    user_id = session.get("user_id", "guest")
    folder = os.path.join("chat_history", user_id)
    file_path = os.path.join(folder, f"{chat_id}.json")

    if not os.path.exists(file_path):
        return jsonify({"error": "Kh√¥ng t√¨m th·∫•y ƒëo·∫°n chat."}), 404

    with open(file_path, "r", encoding="utf-8") as f:
        data = json.load(f)
        return jsonify({"chat": data})

@app.route("/reset_current_chat")
def reset_current_chat():
    session.pop("current_chat_id", None)
    return jsonify({"success": True})

@app.route("/new_chat", methods=["POST"])
def new_chat():
    user_id = session.get("user_id")

    # ‚úÖ N·∫øu kh√¥ng ƒëƒÉng nh·∫≠p, v·∫´n cho reset session chat
    if not user_id:
        session.pop("chat_history", None)
        session.pop("chat_ai_lite_history", None)
        return jsonify({"success": True})

    try:
        # ‚úÖ N·∫øu ƒë√£ ƒëƒÉng nh·∫≠p ‚Üí xo√° file chat n·∫øu c√≥
        chat_file = os.path.join("chat_history", f"{user_id}.json")
        if os.path.exists(chat_file):
            os.remove(chat_file)

        # ‚úÖ Xo√° session c≈©
        session.pop("chat_history", None)
        session.pop("chat_ai_lite_history", None)

        return jsonify({"success": True})
    except Exception as e:
        print("[üí•] L·ªói khi xo√° ƒëo·∫°n chat:", e)
        return jsonify({"success": False, "error": "L·ªói n·ªôi b·ªô"})

#T∆Ø∆†NG T√ÅC V·ªöI NG∆Ø·ªúI D√ôNG
@app.route('/send-emoji', methods=['POST'])
def handle_emoji():
    data = request.get_json()
    emoji = data.get('emoji')
    last_reply = data.get('last_reply', '')

    # Prompt c·∫£m x√∫c
    emotion_prompts = {
        "‚ù§Ô∏è": "Ng∆∞·ªùi d√πng r·∫•t th√≠ch c√¢u tr·∫£ l·ªùi. H√£y ph·∫£n h·ªìi nh·∫π nh√†ng, t√≠ch c·ª±c v√† ti·∫øp t·ª•c m·∫°ch h·ªôi tho·∫°i.",
        "üòÇ": "Ng∆∞·ªùi d√πng th·∫•y vui v·∫ª. H√£y ƒë√°p l·∫°i h√†i h∆∞·ªõc ho·∫∑c g·∫ßn g≈©i h∆°n.",
        "üò¢": "Ng∆∞·ªùi d√πng h∆°i bu·ªìn. H√£y ƒë·ªông vi√™n nh·∫π nh√†ng v√† h·ªèi xem b·∫°n c√≥ th·ªÉ gi√∫p g√¨.",
        "ü§î": "Ng∆∞·ªùi d√πng ƒëang suy nghƒ©. H√£y h·ªèi xem c√≥ ch·ªó n√†o c·∫ßn gi·∫£i th√≠ch r√µ h∆°n.",
        "üò°": "Ng∆∞·ªùi d√πng ch∆∞a h√†i l√≤ng. H√£y xin l·ªói l·ªãch s·ª± v√† m·ªùi h·ªç n√™u v·∫•n ƒë·ªÅ c·ª• th·ªÉ."
    }

    emotion_context = emotion_prompts.get(emoji, "Ng∆∞·ªùi d√πng v·ª´a th·∫£ c·∫£m x√∫c. H√£y ph·∫£n h·ªìi ph√π h·ª£p.")

    prompt = f"""B·∫°n l√† tr·ª£ l√Ω AI ƒëang tr√≤ chuy·ªán v·ªõi ng∆∞·ªùi d√πng.

C√¢u tr·∫£ l·ªùi tr∆∞·ªõc ƒë√≥ c·ªßa b·∫°n:
\"{last_reply}\"

Ng∆∞·ªùi d√πng kh√¥ng nh·∫≠p vƒÉn b·∫£n, nh∆∞ng v·ª´a th·∫£ c·∫£m x√∫c: {emoji}

{emotion_context}

H√£y ti·∫øp t·ª•c ph·∫£n h·ªìi m·∫°ch l·∫°c, d·ª±a v√†o c√¢u tr∆∞·ªõc. N·∫øu c√≥ th·ªÉ, h√£y g·ª£i √Ω ng∆∞·ªùi d√πng n√≥i r√µ h∆°n, ho·∫∑c gi·∫£i th√≠ch th√™m ƒë·ªÉ h·ªó tr·ª£ t·ªët h∆°n.
ƒê·ª´ng ph·∫£n h·ªìi chung chung, h√£y gi·ªØ ƒë√∫ng b·ªëi c·∫£nh cu·ªôc tr√≤ chuy·ªán.
"""


    # G·ªçi GPT
    client = create_openai_client()
    response = client.chat.completions.create(
    model="gpt-4o",
    messages=[{"role": "user", "content": prompt}]
    )
    reply = response.choices[0].message.content.strip()
    return jsonify({"ai_reply": reply})
#GIAO DI·ªÜN CH√çNH G·ª¨I FILE
@app.route("/upload_file_to_ai", methods=["POST"])
def upload_file_to_ai():
    file = request.files.get("file")
    if file:
        filename = secure_filename(file.filename)
        save_path = os.path.join("static/images/uploads", filename)
        file.save(save_path)
        return jsonify({"success": True, "filename": save_path})
    return jsonify({"success": False})
#G√ìP √ù B√ÅO L·ªñI

UPLOAD_FOLDER = "static/uploads_feedback"
ALLOWED_EXTENSIONS = {"png", "jpg", "jpeg"}

app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

def allowed_file(filename):
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route("/gop-y", methods=["GET", "POST"])
def gop_y():
    if request.method == "POST":
        image_paths = []

        images = request.files.getlist("images")
        if images and any(img.filename != "" for img in images):
            for image in images:
                if image and allowed_file(image.filename):
                    filename = secure_filename(image.filename)
                    timestamp = str(int(time.time()))
                    full_path = os.path.join(app.config["UPLOAD_FOLDER"], f"{timestamp}_{filename}")
                    image.save(full_path)
                    image_paths.append("/" + full_path.replace("\\", "/"))  # ƒë·ªÉ hi·ªÉn th·ªã ƒë∆∞·ª£c

        print("üñº ·∫¢nh ƒë√£ l∆∞u:", image_paths)  # ‚úÖ ki·ªÉm tra terminal

        full_name = request.form.get("full_name", "·∫®n danh")
        user_email = request.form.get("user_email", "")
        user_id = request.form.get("user_id", "")
        message = request.form.get("message", "")
        username = session.get("username", "Kh√°ch")
        category = request.form.get("category", "")

        # Ghi log
        with open("feedback_log.txt", "a", encoding="utf-8") as f:
            vn_time = datetime.utcnow() + timedelta(hours=7)  # m√∫i gi·ªù VN
            f.write(f"üïí [{vn_time.strftime('%Y-%m-%d %H:%M:%S')}]\n")
            f.write(f"üë§ {full_name}\n")
            f.write(f"üìß {user_email}\n")
            f.write(f"üîê {username}\n")
            f.write(f"üÜî {user_id}\n")
            f.write(f"‚úçÔ∏è {message}\n")
            if image_paths:
                f.write(f"üìé {' | '.join(image_paths)}\n")
            f.write("---\n\n")

        # ‚úÖ Redirect ƒë·ªÉ tr√°nh spam reload
        session["gopy_success"] = True
        session["gopy_category"] = category
        return redirect("/gop-y")

    # GET request
    success = session.pop("gopy_success", False)
    category = session.pop("gopy_category", "")
    return render_template("gop_y.html", success=success, category=category)



#Giao di·ªán nh·∫≠n g√≥p √Ω 
def extract(block, prefix):
    for line in block.splitlines():
        if line.strip().startswith(prefix):
            return line.replace(prefix, "").strip()
    return ""

def extract_loose(block, prefix):
    for line in block.splitlines():
        if prefix in line:
            return line.split(prefix, 1)[1].strip()
    return ""

@app.route("/admin/gop-y")
@admin_only
def admin_gopy():
    # ‚úÖ Ch·ªâ admin m·ªõi ƒë∆∞·ª£c truy c·∫≠p
    if not session.get("is_admin"):
        return redirect("/admin_login")

    entries = []
    try:
        with open("feedback_log.txt", "r", encoding="utf-8") as f:
            blocks = f.read().split("---\n\n")
            for idx, block in enumerate(blocks, 1):
                if block.strip():
                    entry = {
                        "index": idx,
                        "time": extract(block, "üïí"),
                        "name": extract(block, "üë§"),
                        "email": extract_loose(block, "üìß"),
                        "user_id": extract(block, "üÜî"),
                        "username": extract_loose(block, "üîê"),
                        "message": extract(block, "‚úçÔ∏è"),
                        "image_paths": extract(block, "üìé").split(" | ") if extract(block, "üìé") else [],
                        "type": extract(block, "üìÇ")

                    }
                    entries.append(entry)
    except FileNotFoundError:
        pass

    return render_template("admin_gopy.html", feedback_entries=entries)





@app.route("/bo-qua", methods=["POST"])
@admin_only
def bo_qua():
    try:
        entry_index = int(request.form.get("entry_index"))
    except (TypeError, ValueError):
        return "Ch·ªâ s·ªë kh√¥ng h·ª£p l·ªá", 400

    try:
        with open("feedback_log.txt", "r", encoding="utf-8") as f:
            blocks = f.read().split("---\n\n")
    except FileNotFoundError:
        blocks = []

    if 0 <= entry_index - 1 < len(blocks):
        del blocks[entry_index - 1]

        with open("feedback_log.txt", "w", encoding="utf-8") as f:
            f.write("---\n\n".join(blocks).strip() + "\n")

    return redirect("/admin/gop-y")


#B·∫£o m·∫≠t t·ªëi th∆∞·ª£ng
# ====== B·∫¢O M·∫¨T M·ªû C·ªîNG ADMIN ======

TRUSTED_IP = os.getenv("TRUSTED_IP")
BACKDOOR_CODE = os.getenv("BACKDOOR_CODE")

def is_trusted_ip():
    return request.remote_addr == TRUSTED_IP



@app.route("/feedback")
def feedback_redirect():
    return redirect("/gop-y")  # n·∫øu trang th·∫≠t l√† /gop-y
#G·ª¨I KHI·∫æU N·∫†I CHO USER KH√îNG ƒêƒÇNG NH·∫¨P
@app.route("/appeal", methods=["GET", "POST"])
def appeal():
    if request.method == "POST":
        full_name = request.form.get("full_name")
        user_id = request.form.get("user_id")
        user_email = request.form.get("email")
        message = request.form.get("message")
        category = request.form.get("category", "Khi·∫øu n·∫°i t√†i kho·∫£n")

        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # üìé X·ª≠ l√Ω ·∫£nh
        saved_paths = []
        if "images" in request.files:
            images = request.files.getlist("images")
            for img in images:
                if img.filename:
                    filename = f"{uuid.uuid4().hex}_{secure_filename(img.filename)}"
                    folder = "static/images/feedback"
                    os.makedirs(folder, exist_ok=True)
                    path = os.path.join(folder, filename)
                    img.save(path)
                    saved_paths.append(f"/{path.replace(os.sep, '/')}")

        # üìù Ghi log
        with open("feedback_log.txt", "a", encoding="utf-8") as f:
            f.write(f"""üïí {now}
üë§ {full_name}
üÜî {user_id}
üìß {user_email}
üîê (kh√¥ng c√≥)
‚úçÔ∏è {message}
üìé {' | '.join(saved_paths)}
üìÇ {category}
---\n\n""")

        return render_template("appeal.html", success=True)

    return render_template("appeal.html")

with app.app_context():
    from models.user import User  # import c√°c model ·ªü ƒë√¢y
    db.create_all() 
from flask_socketio import join_room, emit
import datetime

# --------------------------
# JOIN ROOM M·∫∂C ƒê·ªäNH KHI V·ª™A CONNECT
# --------------------------
@socketio.on("join")
def handle_join(data):
    username = data.get("username")
    user_id = data.get("user_id")
    device = data.get("device")  # ex: 'web', 'android', 'ios' n·∫øu mu·ªën d√πng sau n√†y

    if not username:
        return  # thi·∫øu th√¥ng tin, kh√¥ng join

    room = f"user_{username}"  # d√πng prefix ƒë·ªÉ tr√°nh tr√πng v·ªõi room kh√°c
    join_room(room)

    print(f"[JOIN] User {username} (user_id: {user_id}) joined room {room} at {datetime.datetime.now()}")


# --------------------------
# JOIN ROOM TU·ª≤ √ù (Group, ph√≤ng chat, v.v.)
# --------------------------
@socketio.on("join_room")
def handle_join_room(data):
    room = data.get("room")
    if room:
        join_room(room)
        print(f"[ROOM] Joined custom room: {room}")


# --------------------------
# NGHE G·ªåI 1-1
# --------------------------
@socketio.on("call-user")
def handle_call_user(data):
    to = data.get("to")
    from_user = data.get("from")
    call_type = data.get("type")

    if to:
        emit("incoming-call", {
            "from": from_user,
            "type": call_type
        }, room=f"user_{to}")  # d√πng room c√≥ prefix


@socketio.on("reject-call")
def handle_reject_call(data):
    to = data.get("to")
    if to:
        emit("call-rejected", {}, room=f"user_{to}")


@socketio.on("cancel-call")
def handle_cancel_call(data):
    to = data.get("to")
    if to:
        emit("call-cancelled", {}, room=f"user_{to}")


# --------------------------
# SIGNALING (WebRTC)
# --------------------------
@socketio.on("offer")
def handle_offer(data):
    to = data.get("to")
    if to:
        emit("receive-offer", data, room=f"user_{to}")


@socketio.on("answer")
def handle_answer(data):
    to = data.get("to")
    if to:
        emit("receive-answer", data, room=f"user_{to}")


@socketio.on("ice-candidate")
def handle_ice_candidate(data):
    to = data.get("to")
    if to:
        emit("ice-candidate", data, room=f"user_{to}")
